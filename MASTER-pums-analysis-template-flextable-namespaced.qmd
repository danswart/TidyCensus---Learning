---
title: "PUMS Pay Gap Analysis Template"
subtitle: "Enhanced Template with Educational Attainment Filtering and Debug Tracking"
description: "Using ACS5 database with education level parameters - Debug Version"
authors: 
  - name: "Dan Swart, CPA (ret)"
  - name: "Claude Sonnet 4.5"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # Hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: true
    include-in-header:
      - text: 
          <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Cabin&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Schoolbell&display=swap" rel="stylesheet">
      - header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 16pt
    mainfont: "Cabin"
  

    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px



  # docx:
  #   highlight-style: github
  #   fig_caption: true



editor: source

quarto:
  render:
    cache-refresh: true


# for .qmd filesd
execute:
  echo: true
  message: false
  warning: false
  eval: true
  fig-width: 12
  fig-height: 10


# for .rmd files
knitr:
  opts_chunk:
    echo: true
    error: false
    warning: false
    message: false
    cache: false


---



```{r}
#| label: setup
#| include: false


# install.packages(c("mapview", "survey", "srvyr", "arcgislayers"))

# census_api_key("95496766c51541ee6f402c1e1a8658581285b759", install = TRUE, overwrite = TRUE)


# # load libraries - NOT NEEDED


# Force dplyr's select to take precedence
select <- dplyr::select
filter <- dplyr::filter

# Options
options(scipen = 999)
options(qic.clshade = T) # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.linecol = 'black') # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.signalcol = "firebrick") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.targetcol = "purple") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(DT.options = list(dom = 'pBlfrti')) # Add buttons, filtering, and top (t) pagination controls
options(shiny.maxRequestSize = 50 * 1024^2) # Set upload maximum to 50 MB
options(tigris_use_cache = TRUE)
options(device = "RStudioGD") 


# Flextable defaults:
flextable::set_flextable_defaults(
  font.size = 14, 
  font.family = "Cabin",
  font.color = "black",
  table.layout = "fixed",
  border.color = "darkgray",
  padding.top = 3, padding.bottom = 3,
  padding.left = 4, padding.right = 4,
  line_spacing = 1.3,
  digits = 2,
  decimal.mark = ".",
  big.mark = " ",
  na_str = "<na>"
)


#
# # Sample Code:
# flextable::flextable(violations) |>
 #  flextable::set_header_labels(
 #    Variable = "Variable",
 #    Measurement = "Measurement",
 #    Likely_Impact = "Likely Impact"
 #  ) |>
#    flextable::add_header_lines(values = "Frequent Violations of Scientific Method in Current So-Called 'Equity' Research") |>
#   flextable::color(i = 1, color = "blue", part = "header") |>
#   flextable::italic(i = 1, part = "header") |>
#   flextable::align(i = 1, align = "center", part = "header") |>
#   flextable::fontsize(i = 1, size = 14, part = "header") |>
#   flextable::bg(i = 1, bg = "white", part = "header") |>
#   flextable::bg(i = 2, bg = "palegreen", part = "header") |>
#   flextable::bold(i = 1:2, part = "header") |>
#   flextable::bold(i = 1:7, j = 1, part = "body") |>
#   ftExtra::colformat_md() |> 
#   flextable::autofit()
  

# Flextable built-in themes:
  # flextable::theme_alafoli()	|>  # BLAH
  # flextable::theme_apa()  # THIS IS NICE
  # flextable::theme_booktabs() |>  # NICE, MORE COMPACT
  # flextable::theme_box() |>   # OK, INCLUDES CELL BORDERS
  # flextable::theme_tron() |>  # 'DARK MODE' BLUE TEXT
  # flextable::theme_tron_legacy() |>   # 'DARK MODE' YELLOW TEXT
  # flextable::theme_vader() |>    # 'DARK MODE' WHITE TEXT
  # flextable::theme_vanilla() |>   # NOT SPECIAL
  # flextable::theme_zebra()	|>
  #

# Flextable titles:
  # flextable::colformat_double(j = c("Mean", "SD", "N"), big.mark = ",", digits = 1) |>
  # flextable::flextable(variance_comparison) |>
  #  flextable::add_header_lines(values = "The Within-Group vs Between-Group Variance Problem") |>

# Flextable Title theming at table-level:
  #  flextable::color(i = 1, color = "blue", part = "header") |>
  #  flextable::italic(i = 1, part = "header") |>
  #  flextable::align(i = 1, align = "center", part = "header") |>
  #  flextable::fontsize(i = 1, size = 14, part = "header") |>
  #  flextable::bg(i = 1, bg = "white", part = "header") |>

# Flextable standard table background colors:
  #  flextable::bg(i = 2, bg = "palegreen", part = "header") |>
  

# Flextable reading markdown:
  #  ftExtra::colformat_md() |> 

# Flextable auto-sizing cell widths:
  #  flextable::autofit() 
 
 # Flextable background based on SPECIFIC cell contents:
  #
  # flextable::bg(i = ~ Impact_on_Validity == "High", j = "Impact_on_Validity", bg = "#ffcccc") |>
 # flextable::bg(i = ~ Impact_on_Validity == "Medium", j = "Impact_on_Validity", bg = "#ffffcc") |>
  #
  # 
  # Apply yellow background to any cell containing "Yes":

  # for (col in base::names(hypotheses_data)) {
  #   yes_rows <- base::which(hypotheses_data[[col]] == "Yes")
  #   if (base::length(yes_rows) > 0) {
  #     ft <- ft |>
  #       flextable::bg(i = yes_rows, j = col, bg = "yellow", part = "body")
  #   }
  # } 
  #
  # Apply to last row of table:
  #
  #



# Set global theme for consistent plots
ggplot2::theme_set(
  ggplot2::theme_minimal(base_size = 20) +
    ggplot2::theme(
      plot.title.position = "plot",
      plot.title = ggtext::element_textbox_simple(
        family = "Cabin",
        face = "bold",
        color = "darkgreen",
        size = 26,
        fill = "yellow",
        lineheight = 1.2,
        padding = ggplot2::margin(5.5, 5.5, 0.0, 5.5),
        margin = ggplot2::margin(0, 0, 5.5, 0)
      ),
      plot.subtitle = ggtext::element_textbox_simple(
        family = "Cabin",
        color = "darkgreen",
        face = "bold",
        size = 24,
        fill = "yellow",
        lineheight = 1.2,
        padding = ggplot2::margin(5.5, 5.5, 5.5, 5.5),
        margin = ggplot2::margin(10.5, 0, 5.5, 0)
      ),
      plot.caption = ggtext::element_markdown(
        family = "Cabin",
        size = 22,
        hjust = 1,
        color = "darkblue",
        face = "italic",
        fill = "yellow",
        lineheight = 1.0
      ),
      axis.text.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20,
        angle = 45,
        hjust = 1
      ),
        # ggplot2::element_blank(),
      axis.title.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20),
        # ggplot2::element_blank(),
      axis.text.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20,
        angle = 45,
        hjust = 1
      ),
        # ggplot2::element_blank(),
      axis.title.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20),
        # ggplot2::element_blank(),
      strip.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black",
        size = ggplot2::rel(1.1),
        face = "italic",
        margin = ggplot2::margin(2, 0, 0.5, 0, "lines")
      ),
      axis.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black"),
      panel.background = ggplot2::element_rect(fill = "white", color = NA),
      plot.background = ggplot2::element_rect(fill = "white", color = NA),
      legend.position = "none",
      panel.spacing.x = grid::unit(1.5, "cm"),
      panel.spacing.y = grid::unit(1.5, "cm"),
      plot.margin = ggplot2::margin(20, 20, 20, 20, "pt")
    )
)



  
# Set seed for reproducibility
base::set.seed(123)

```

### Create Cache Directories

```{r}
#| label: create cache directory

# Create cache directory
if (!base::dir.exists("cache_data")) {
  base::dir.create("cache_data")
}

```

### Create Debug Tracking Dataframe

```{r}
#| label: debug tracking dataframe

# Create debug tracking dataframe
debug_tracker <- base::data.frame(
  Step = base::character(),
  Description = base::character(),
  Sample_Size = base::numeric(),
  stringsAsFactors = FALSE
)

```



================================================================================
                        MODIFICATION INSTRUCTIONS
================================================================================

This template analyzes pay gaps between two demographic groups using PUMS data.
To adapt for your research, modify the ANALYSIS PARAMETERS section below.

### STEP 1: DEFINE YOUR GROUPS


- Group A and Group B can be any combination of sex, marital status, and education level
  - Use tidycensus::pums_variables to find exact codes:
     > library(tidycensus)
     
     > View(pums_variables)
     
     > Search for SEX, MAR, SCHL, or other vari  ables


```{r}
#| label: common-codes-reference

# Create reference table for common PUMS codes
common_codes_df <- base::data.frame(
  Variable = base::c(
    "SEX", "SEX",
    "MAR", "MAR", "MAR", "MAR", "MAR",
    "SCHL", "SCHL", "SCHL", "SCHL", "SCHL", "SCHL"
  ),
  Code = base::c(
    "1", "2",
    "1", "2", "3", "4", "5",
    "16", "18", "21", "22", "23", "24"
  ),
  Description = base::c(
    "Male", "Female",
    "Married", "Widowed", "Divorced", "Separated", "Never married",
    "Regular high school diploma", "Some college, but less than 1 year",
    "Bachelor's degree", "Master's degree", 
    "Professional degree beyond bachelor's", "Doctorate degree"
  ),
  stringsAsFactors = FALSE
)

flextable::flextable(common_codes_df) |>
  flextable::add_header_lines(values = "Common PUMS Variable Codes Reference") |>
  flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
  flextable::color(i = 1, color = "darkblue", part = "header") |>
  flextable::bold(i= 1:2, part = "header") |>
  flextable::fontsize(i = 1:2, size = 14, part = "header") |>
  flextable::align(i = 1, align = "center", part = "header") |>
  flextable::bg(i = 2, bg = "palegreen", part = "header") |>
  flextable::merge_v(j = "Variable") |>
#  flextable::valign(j = "Variable", valign = "top") |>
  flextable::autofit()

```





## FILTERING FOR EDUCATIONAL ATTAINMENT:

You can filter by:

1. Specific education code: e.g., "23" for professional degree

2. Multiple codes: c("22", "23", "24") for graduate degrees

3. Education labels using regex: "Bachelor|Master" 

4. NULL to include all education levels




## FINDING OCCUPATIONS:

Occupations use partial text matching on OCCP_label field. To find occupations:

  > library(tidycensus)
  
  > pums_vars <- pums_variables
  
  > View(pums_vars %>% filter(var_code == "OCCP"))  # See all occupation labels
  
  
Example: "Manager" matches all manager types, "Nurse" matches all nursing occupations
For specific occupations, use more precise terms (e.g., "Registered nurses" vs "Nurse")



## STEP 2: UPDATE PARAMETERS

Edit the ANALYSIS PARAMETERS section below with your values


## STEP 3: UPDATE REPORT TEXT

Search and replace the group labels throughout the document


## STEP 4: CLEAR CACHE (if changing data parameters)

Delete the cache_data folder to force fresh data download


## STEP 5: RENDER

Click "Render" in RStudio or run: quarto render yourfile.qmd




### Un-comment to look for PUMS education Codes

```{r pums-education-codes}

# # Load all variables available in PUMS
# View(tidycensus::pums_variables)
# 
# # View education codes specifically
# education_codes <- tidycensus::pums_variables |>
#   dplyr::filter(var_code == "SCHL", survey == "acs5", year == 2023) |>
#   dplyr::select(val_label)
# View(education_codes)

```


# ANALYZE PARAMETERS {.unnumbered}

**Modify these parameters for your specific analysis:**

#### MAIN ANALYSIS PARAMETERS

```{r}
#| label: main parameters


# ============================================
#           MAIN ANALYSIS PARAMETERS
# ============================================

# Geographic and time parameters
STATE_CODE <- "TX"           # State abbreviation
SURVEY_YEAR <- 2023          # Year of ACS data
AGE_MIN <- 40                # Minimum age
AGE_MAX <- 64                # Maximum age

```

#### SET EDUCATION CODES

```{r}
#| label: set education codes



# ============================================
#        EDUCATIONAL ATTAINMENT FILTERS
# ============================================
# Use NULL to include all education levels, or specify codes/labels

# Option 1: Filter by specific education code(s)
# Single code: "23" for professional degree
# Multiple codes: c("21", "22", "23", "24") for bachelor's and above
# NULL for all education levels

GROUP_A_EDUCATION_CODE <- 23  # NULL or a code like "23" for professional degree
GROUP_B_EDUCATION_CODE <- 23  # NULL or a code like c("21", "22") for bachelor's/master's


# Option 2: Filter by education label pattern (regex)
# Examples: "Bachelor", "Master|Professional", "degree"
# NULL to not filter by label

GROUP_A_EDUCATION_LABEL <- NULL
GROUP_B_EDUCATION_LABEL <- NULL


# Minimum education level (optional)
# Filters to include only this code and higher
# Common thresholds: "16" (HS), "21" (Bachelor's), "22" (Master's)
MIN_EDUCATION_CODE <- NULL

```

####  DEFINE GROUP DEFINITIONS

```{r}
#| label: group definitions

# ============================================
#           GROUP DEFINITIONS
# ============================================

# Group A definition
GROUP_A_SEX <- "2"
GROUP_A_MAR <- "5"
GROUP_A_LABEL <- "Never-Married Females"

# Group B definition
GROUP_B_SEX <- "1"
GROUP_B_MAR <- "5"
GROUP_B_LABEL <- "Never-Married Males"

```


#### SET SAMPLE SIZES

```{r}
#| label: set sample sizes

# Analysis options
MIN_OCCUPATION_COUNT <- 30
TOP_N_OCCUPATIONS <- 20

```

#### SPECIFY OCCUPATIONS

```{r}
#| label: specify Occupations


# Specify Occupations to analyze for pay gaps (partial text matching)
OCCUPATION_GAP_ANALYSIS <- base::c(
  "MED-Physicians", 
  "MED-Surgeons", 
  "MED-Dentists", 
  "MED-Pharmacists", 
  "LGL-Lawyers, And Judges, Magistrates, And Other Judicial Workers", 
  "EDU-Postsecondary Teachers", 
  "MGR-General And Operations Managers", 
  "EDU-Secondary School Teachers", 
  "MED-Registered Nurses", 
  "ENG-Engineer", 
  "FIN-Accountants And Auditors", 
  "MGR-Sales Managers"
)

# Additional occupations for detailed search examples
OCCUPATION_SEARCH_EXAMPLES <- base::c("Clerk", "Driver")

# Note: These use partial matching. "Manager" matches all manager occupations.
# For specific occupations, use precise terms like "General and operations managers"

```

#### CACHE MANAGEMENT

```{r}
#| label: cache management


# Cache management
CACHE_PREFIX <- "nm_fem_vs_nm_male_edu"
FORCE_REFRESH <- FALSE



# ============================================
#           DERIVED PARAMETERS
# ============================================

# Create unique cache paths based on parameters
cache_raw <- base::paste0("cache_data/", CACHE_PREFIX, "_raw.rds")
cache_processed <- base::paste0("cache_data/", CACHE_PREFIX, "_processed.rds")
cache_analysis <- base::paste0("cache_data/", CACHE_PREFIX, "_analysis.rds")

```


#### CREATE ANALYSIS DESCRIPTION WITH DEBUGGING


```{r}
#| label: build text descripts


education_desc_a <- if (!base::is.null(GROUP_A_EDUCATION_CODE)) {
  desc <- base::paste0(" (Edu: ", base::paste(GROUP_A_EDUCATION_CODE, collapse = ","), ")")
  base::cat("Group A education description (from code):", desc, "\n")
  desc
} else if (!base::is.null(GROUP_A_EDUCATION_LABEL)) {
  desc <- base::paste0(" (Edu: ", GROUP_A_EDUCATION_LABEL, ")")
  base::cat("Group A education description (from label):", desc, "\n")
  desc
} else if (!base::is.null(MIN_EDUCATION_CODE)) {
  desc <- base::paste0(" (Edu >= ", MIN_EDUCATION_CODE, ")")
  base::cat("Group A education description (from min):", desc, "\n")
  desc
} else {
  base::cat("Group A education description: None (all education levels)\n")
  ""
}

education_desc_b <- if (!base::is.null(GROUP_B_EDUCATION_CODE)) {
  desc <- base::paste0(" (Edu: ", base::paste(GROUP_B_EDUCATION_CODE, collapse = ","), ")")
  base::cat("Group B education description (from code):", desc, "\n")
  desc
} else if (!base::is.null(GROUP_B_EDUCATION_LABEL)) {
  desc <- base::paste0(" (Edu: ", GROUP_B_EDUCATION_LABEL, ")")
  base::cat("Group B education description (from label):", desc, "\n")
  desc
} else if (!base::is.null(MIN_EDUCATION_CODE)) {
  desc <- base::paste0(" (Edu >= ", MIN_EDUCATION_CODE, ")")
  base::cat("Group B education description (from min):", desc, "\n")
  desc
} else {
  base::cat("Group B education description: None (all education levels)\n")
  ""
}

ANALYSIS_DESCRIPTION <- base::paste0(
  "Comparing ", GROUP_A_LABEL, education_desc_a, 
  " vs ", GROUP_B_LABEL, education_desc_b,
  " in ", STATE_CODE, " (Ages ", AGE_MIN, "-", AGE_MAX, ")"
)

base::cat("\n=== ANALYSIS CONFIGURATION ===\n")
base::cat("Description:", ANALYSIS_DESCRIPTION, "\n")
base::cat("Data Year:", SURVEY_YEAR, "\n")
base::cat("Cache Prefix:", CACHE_PREFIX, "\n")
base::cat("===============================\n\n")

```


# Data Functions

```{r functions}

# Enhanced function to filter PUMS data with comprehensive debugging
filter_pums_data <- function(data, sex_code, mar_code = NULL, 
                             edu_code = NULL, edu_label = NULL,
                             min_edu = MIN_EDUCATION_CODE,
                             age_min = AGE_MIN, age_max = AGE_MAX,
                             group_label = "Group") {
  
  base::cat("\n=== FILTERING", group_label, "===\n")
  base::cat("Starting sample size:", base::nrow(data), "\n")
  
  # Track unique values before filtering
  base::cat("\nUnique SEX values in data:", base::unique(data$SEX), "\n")
  base::cat("Filtering for SEX =", sex_code, "\n")
  
  result <- data |>
    dplyr::filter(SEX == sex_code)
  base::cat("After SEX filter:", base::nrow(result), "rows\n")
  
  result <- result |>
    dplyr::filter(AGEP >= age_min & AGEP <= age_max)
  base::cat("After AGE filter (", age_min, "-", age_max, "):", base::nrow(result), "rows\n")
  
  result <- result |>
    dplyr::filter(PERNP > 0)
  base::cat("After PERNP > 0 filter:", base::nrow(result), "rows\n")
  
  result <- result |>
    dplyr::filter(OCCP != "000N")
  base::cat("After OCCP != '000N' filter:", base::nrow(result), "rows\n")
  
  result <- result |>
    dplyr::filter(!base::is.na(OCCP))
  base::cat("After !is.na(OCCP) filter:", base::nrow(result), "rows\n")
  
  result <- result |>
    dplyr::filter(!base::is.na(PERNP))
  base::cat("After !is.na(PERNP) filter:", base::nrow(result), "rows\n")
  
  # Apply marital status filter if specified
  if (!base::is.null(mar_code)) {
    base::cat("\nUnique MAR values in current data:", base::unique(result$MAR), "\n")
    base::cat("Filtering for MAR =", mar_code, "\n")
    result <- result |> 
      dplyr::filter(MAR == mar_code)
    base::cat("After MAR filter:", base::nrow(result), "rows\n")
  } else {
    base::cat("No MAR filter applied\n")
  }
  
  # Apply education code filter if specified
  if (!base::is.null(edu_code)) {
    base::cat("\nUnique SCHL values in current data:", base::length(base::unique(result$SCHL)), "unique values\n")
    base::cat("Sample of SCHL values:", utils::head(base::unique(result$SCHL), 10), "\n")
    
    if (base::length(edu_code) == 1) {
      base::cat("Filtering for single SCHL code:", edu_code, "\n")
      # Check if any records match before filtering
      matches <- base::sum(result$SCHL == edu_code, na.rm = TRUE)
      base::cat("Records matching SCHL ==", edu_code, ":", matches, "\n")
      result <- result |> 
        dplyr::filter(SCHL == edu_code)
    } else {
      base::cat("Filtering for multiple SCHL codes:", base::paste(edu_code, collapse = ", "), "\n")
      matches <- base::sum(result$SCHL %in% edu_code, na.rm = TRUE)
      base::cat("Records matching SCHL in specified codes:", matches, "\n")
      result <- result |> 
        dplyr::filter(SCHL %in% edu_code)
    }
    base::cat("After SCHL code filter:", base::nrow(result), "rows\n")
  } else {
    base::cat("No SCHL code filter applied\n")
  }
  
  # Apply education label filter if specified
  if (!base::is.null(edu_label)) {
    base::cat("\nFiltering for SCHL_label pattern:", edu_label, "\n")
    if ("SCHL_label" %in% base::names(result)) {
      matches <- base::sum(stringr::str_detect(result$SCHL_label, stringr::regex(edu_label, ignore_case = TRUE)), na.rm = TRUE)
      base::cat("Records matching pattern:", matches, "\n")
      result <- result |> 
        dplyr::filter(stringr::str_detect(SCHL_label, stringr::regex(edu_label, ignore_case = TRUE)))
    } else {
      base::cat("WARNING: SCHL_label column not found in data\n")
    }
    base::cat("After SCHL label filter:", base::nrow(result), "rows\n")
  }
  
  # Apply minimum education filter if specified
  if (!base::is.null(min_edu)) {
    base::cat("\nFiltering for SCHL >=", min_edu, "\n")
    matches <- base::sum(result$SCHL >= min_edu, na.rm = TRUE)
    base::cat("Records with SCHL >=", min_edu, ":", matches, "\n")
    result <- result |> 
      dplyr::filter(SCHL >= min_edu)
    base::cat("After minimum SCHL filter:", base::nrow(result), "rows\n")
  }
  
  base::cat("\nFINAL", group_label, "sample size:", base::nrow(result), "\n")
  base::cat("=============================\n")
  
  base::return(result)
}

```


```{r}
#| label: pay gap calc function

# Function to calculate pay gap with statistical testing - WITH ERROR HANDLING
calculate_pay_gap <- function(data, occupation_filter = NULL) {
  
  # Apply occupation filter if specified
  if (!base::is.null(occupation_filter)) {
    data <- data |>
      dplyr::filter(stringr::str_detect(OCCP_label, stringr::regex(occupation_filter, ignore_case = TRUE)))
  }
  
  # Check for sufficient data
  if (base::nrow(data) < 10) base::return(NULL)
  
  # Check both groups are present
  groups <- base::unique(data$group)
  if (base::length(groups) < 2) base::return(NULL)
  
  # Try to use survey weights, fall back to unweighted if needed
  group_stats <- base::tryCatch({
    # Attempt survey-weighted analysis
    svy_data <- data |> 
      srvyr::as_survey_design(weights = PWGTP)
    
    svy_data |>
      dplyr::group_by(group) |>
      dplyr::summarise(
        count = srvyr::survey_total(),
        mean_earnings = srvyr::survey_mean(PERNP, na.rm = TRUE),
        median_earnings = srvyr::survey_median(PERNP, na.rm = TRUE),
        .groups = "drop"
      )
  }, error = function(e) {
    # Fall back to unweighted analysis
    data |>
      dplyr::group_by(group) |>
      dplyr::summarise(
        count = dplyr::n(),
        mean_earnings = base::mean(PERNP, na.rm = TRUE),
        median_earnings = stats::median(PERNP, na.rm = TRUE),
        .groups = "drop"
      )
  })
  
  # Calculate gap (Group B - Group A)
  group_a_stats <- dplyr::filter(group_stats, group == "Group_A")
  group_b_stats <- dplyr::filter(group_stats, group == "Group_B")
  
  if (base::nrow(group_a_stats) == 0 || base::nrow(group_b_stats) == 0) base::return(NULL)
  
  gap_dollars <- group_b_stats$mean_earnings - group_a_stats$mean_earnings
  gap_percent <- (gap_dollars / group_a_stats$mean_earnings) * 100
  
  # Statistical test - try survey test first, then regular t-test
  p_value <- base::tryCatch({
    svy_data <- data |> 
      srvyr::as_survey_design(weights = PWGTP)
    test <- survey::svyttest(PERNP ~ group, svy_data)
    test$p.value
  }, error = function(e) {
    # Try regular t-test as fallback
    base::tryCatch({
      test <- stats::t.test(PERNP ~ group, data = data)
      test$p.value
    }, error = function(e2) NA)
  })
  
  base::return(base::list(
    occupation = base::ifelse(base::is.null(occupation_filter), "All Occupations", occupation_filter),
    group_a_mean = group_a_stats$mean_earnings,
    group_b_mean = group_b_stats$mean_earnings,
    gap_dollars = gap_dollars,
    gap_percent = base::round(gap_percent, 1),
    p_value = p_value,
    significant = !base::is.na(p_value) && p_value < 0.05,
    group_a_count = group_a_stats$count,
    group_b_count = group_b_stats$count
  ))
}

```


```{r}
#| label: function to create formatted tables


# Function to create formatted tables using flextable
create_summary_table <- function(data, title = NULL) {
  ft <- flextable::flextable(data) |>
      flextable::add_header_lines(values = title) |>
      flextable::color(i = 1, color = "darkblue", part = "header") |>
      flextable::bold(i = 1, part = "header") |>
      flextable::fontsize(i = 1, size = 14, part = "header") |>
      flextable::align(i = 1, align = "center", part = "header") |>
      flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
      flextable::bg(i = 2, bg = "palegreen", part = "header") |> 
      flextable::autofit()
  
  if (!base::is.null(title)) {
    ft <- ft |>
      flextable::add_header_lines(values = title) |>
      flextable::color(i = 1, color = "darkblue", part = "header") |>
      flextable::bold(i = 1, part = "header") |>
      flextable::fontsize(i = 1, size = 14, part = "header") |>
      flextable::align(i = 1, align = "center", part = "header") |>
      flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
      flextable::bg(i = 2, bg = "palegreen", part = "header") |> 
      flextable::autofit()
  }
  
  ft
}

```


```{r}
#| label: Helper function to explore available occupations in the data


# Helper function to explore available occupations in the data
explore_occupations <- function(search_term = NULL, data = pums_data) {
  # Get unique occupations with counts
  occ_summary <- data |>
    dplyr::filter(!base::is.na(OCCP_label), OCCP != "000N") |>
    dplyr::group_by(OCCP, OCCP_label) |>
    dplyr::summarise(count = dplyr::n(), .groups = "drop") |>
    dplyr::arrange(dplyr::desc(count))
  
  # Filter if search term provided
  if (!base::is.null(search_term)) {
    occ_summary <- occ_summary |>
      dplyr::filter(stringr::str_detect(OCCP_label, stringr::regex(search_term, ignore_case = TRUE)))
  }
  
  base::return(occ_summary)
}

```


```{r}
#| label: function to explore education levels in the data

# New function to explore education levels in the data
explore_education <- function(data = pums_data) {
  edu_summary <- data |>
    dplyr::filter(!base::is.na(SCHL_label)) |>
    dplyr::group_by(SCHL, SCHL_label) |>
    dplyr::summarise(
      count = dplyr::n(),
      mean_earnings = base::mean(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) |>
    dplyr::arrange(SCHL)
  
  base::return(edu_summary)
}

```


```{r}
#| label: Function to search for specific occupations - WITH ERROR HANDLING

# Function to search for specific occupations - WITH ERROR HANDLING
search_occupation <- function(search_term, data = group_a_data) {
  
  # First filter to check if any matches exist
  filtered_data <- data |>
    dplyr::filter(stringr::str_detect(OCCP_label, stringr::regex(search_term, ignore_case = TRUE)))
  
  # Return NULL if no matches found or insufficient data
  if (base::nrow(filtered_data) < 5) {
    base::return(NULL)
  }
  
  # Try to process with survey weights, fall back to simple means if survey fails
  matching <- base::tryCatch({
    # Attempt survey-weighted analysis
    filtered_data |>
      srvyr::as_survey_design(weights = PWGTP) |>
      dplyr::group_by(OCCP_label) |>
      dplyr::summarise(
        count = srvyr::survey_total(),
        mean_earnings = srvyr::survey_mean(PERNP, na.rm = TRUE),
        .groups = "drop"
      ) |>
      dplyr::arrange(dplyr::desc(mean_earnings))
  }, error = function(e) {
    # Fall back to unweighted analysis if survey design fails
    filtered_data |>
      dplyr::group_by(OCCP_label) |>
      dplyr::summarise(
        count = dplyr::n(),
        mean_earnings = base::mean(PERNP, na.rm = TRUE),
        .groups = "drop"
      ) |>
      dplyr::arrange(dplyr::desc(mean_earnings))
  })
  
  # Format and return results
  base::return(matching |>
         dplyr::mutate(
           Occupation = OCCP_label,
           `Sample Size` = base::round(count),
           `Mean Earnings` = scales::dollar(mean_earnings)
         ) |>
         dplyr::select(Occupation, `Sample Size`, `Mean Earnings`))
}
```



# Data Collection

```{r data-collection}
#| cache: true

base::cat("\n### DATA COLLECTION PHASE ###\n")

# Check cache or download fresh data
if (!FORCE_REFRESH && base::file.exists(cache_raw)) {
  base::cat("Loading cached data from:", cache_raw, "\n")
  pums_data <- base::readRDS(cache_raw)
  base::cat("Cached data loaded successfully\n")
} else {
  base::cat("Downloading PUMS data from Census API...\n")
  base::cat("State:", STATE_CODE, "\n")
  base::cat("Year:", SURVEY_YEAR, "\n")
  base::cat("This may take several minutes...\n\n")
  
  # Download all PUMS data
  base::invisible(utils::capture.output(
    pums_data <- tidycensus::get_pums(
      variables = base::c("SEX", "MAR", "SCHL", "OCCP", "PINCP", "PERNP", "AGEP", "COW"),
      state = STATE_CODE,
      survey = "acs5",
      year = SURVEY_YEAR,
      recode = TRUE
    )
  ))
  
  # Save to cache
  base::saveRDS(pums_data, cache_raw)
  base::cat("Data downloaded and saved to cache:", cache_raw, "\n")
}

base::cat("\n=== RAW DATA SUMMARY ===\n")
base::cat("Total records downloaded:", base::nrow(pums_data), "\n")
base::cat("Variables included:", base::paste(base::names(pums_data), collapse = ", "), "\n")

```


```{r}
#| label: check SCHL values

# Check SCHL values
base::cat("\n=== EDUCATION (SCHL) VALUES CHECK ===\n")
schl_summary <- pums_data |>
  dplyr::filter(!base::is.na(SCHL)) |>
  dplyr::group_by(SCHL) |>
  dplyr::summarise(count = dplyr::n()) |>
  dplyr::arrange(dplyr::desc(count))

base::cat("Total unique SCHL codes:", base::nrow(schl_summary), "\n")
base::cat("Top 10 SCHL codes by frequency:\n")

# Display as flextable
schl_top10 <- utils::head(schl_summary, 10)

flextable::flextable(schl_top10) |>
  flextable::set_header_labels(
    SCHL = "Education Code",
    count = "Count"
  ) |>
  flextable::colformat_int(j = c("count"), big.mark = ",") |>
  flextable::add_header_lines(values = "Top 10 SCHL Codes by Frequency") |>
  flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
  flextable::color(i = 1, color = "darkblue", part = "header") |>
  flextable::bold(i = 1:2, part = "header") |>
  flextable::align(i = 1, align = "center", part = "header") |> 
  flextable::bg(i = 2, bg = "palegreen", part = "header") |>
  ftExtra::colformat_md() |> 
  flextable::autofit()

# Check if code 23 exists
if (23 %in% schl_summary$SCHL) {
  base::cat("\nSCHL code 23 found:", schl_summary$count[schl_summary$SCHL == 23], "records\n")
} else if ("23" %in% schl_summary$SCHL) {
  base::cat("\nSCHL code '23' (character) found:", schl_summary$count[schl_summary$SCHL == "23"], "records\n")
} else {
  base::cat("\nWARNING: SCHL code 23 NOT found in data!\n")
}

base::cat("================================\n")
```


# Data Processing

```{r data-processing}
#| cache: true

base::cat("\n### DATA PROCESSING PHASE ###\n")

# Check cache or process data
if (!FORCE_REFRESH && base::file.exists(cache_processed)) {
  base::cat("Loading cached processed data from:", cache_processed, "\n")
  processed_data <- base::readRDS(cache_processed)
  group_a_data <- processed_data$group_a
  group_b_data <- processed_data$group_b
  combined_data <- processed_data$combined
  base::cat("Cached processed data loaded successfully\n")
  base::cat("Group A size from cache:", base::nrow(group_a_data), "\n")
  base::cat("Group B size from cache:", base::nrow(group_b_data), "\n")
} else {
  base::cat("Processing data with filters...\n\n")
  
  # Check data types before filtering
  base::cat("=== DATA TYPE CHECK ===\n")
  base::cat("SCHL data type:", base::class(pums_data$SCHL), "\n")
  base::cat("GROUP_A_EDUCATION_CODE type:", base::class(GROUP_A_EDUCATION_CODE), "\n")
  base::cat("GROUP_B_EDUCATION_CODE type:", base::class(GROUP_B_EDUCATION_CODE), "\n")
  
  # Convert education codes to match data type if needed
  if (base::is.numeric(pums_data$SCHL[1]) && base::is.numeric(GROUP_A_EDUCATION_CODE)) {
    base::cat("Both SCHL and education codes are numeric - good!\n")
  } else if (base::is.character(pums_data$SCHL[1]) && base::is.numeric(GROUP_A_EDUCATION_CODE)) {
    base::cat("Converting numeric education codes to character to match SCHL\n")
    GROUP_A_EDUCATION_CODE <- base::as.character(GROUP_A_EDUCATION_CODE)
    GROUP_B_EDUCATION_CODE <- base::as.character(GROUP_B_EDUCATION_CODE)
  } else if (base::is.numeric(pums_data$SCHL[1]) && base::is.character(GROUP_A_EDUCATION_CODE)) {
    base::cat("Converting character education codes to numeric to match SCHL\n")
    GROUP_A_EDUCATION_CODE <- base::as.numeric(GROUP_A_EDUCATION_CODE)
    GROUP_B_EDUCATION_CODE <- base::as.numeric(GROUP_B_EDUCATION_CODE)
  }
  
  # Filter Group A with education parameters
  group_a_data <- filter_pums_data(
    pums_data, 
    GROUP_A_SEX, 
    GROUP_A_MAR,
    edu_code = GROUP_A_EDUCATION_CODE,
    edu_label = GROUP_A_EDUCATION_LABEL,
    group_label = base::paste("Group A -", GROUP_A_LABEL)
  )
  
  # Filter Group B with education parameters
  group_b_data <- filter_pums_data(
    pums_data, 
    GROUP_B_SEX, 
    GROUP_B_MAR,
    edu_code = GROUP_B_EDUCATION_CODE,
    edu_label = GROUP_B_EDUCATION_LABEL,
    group_label = base::paste("Group B -", GROUP_B_LABEL)
  )
  
  # Combine with group labels
  combined_data <- dplyr::bind_rows(
    group_a_data |> dplyr::mutate(group = "Group_A"),
    group_b_data |> dplyr::mutate(group = "Group_B")
  )
  
  base::cat("\n=== FINAL PROCESSING SUMMARY ===\n")
  base::cat("Group A (", GROUP_A_LABEL, "):", base::nrow(group_a_data), "records\n")
  base::cat("Group B (", GROUP_B_LABEL, "):", base::nrow(group_b_data), "records\n")
  base::cat("Combined data:", base::nrow(combined_data), "records\n")
  
  # Save processed data
  processed_data <- base::list(
    group_a = group_a_data,
    group_b = group_b_data,
    combined = combined_data
  )
  base::saveRDS(processed_data, cache_processed)
  base::cat("\nData processed and saved to cache:", cache_processed, "\n")
}

```

### Display sample summary

```{r}

# Display sample summary
sample_summary <- base::data.frame(
  Group = base::c(GROUP_A_LABEL, GROUP_B_LABEL),
  Sample_Size = base::c(base::nrow(group_a_data), base::nrow(group_b_data)),
  Age_Range = base::paste0(AGE_MIN, "-", AGE_MAX),
  stringsAsFactors = FALSE
)

base::cat("\n### SAMPLE COMPOSITION TABLE ###\n")
create_summary_table(sample_summary, "Sample Composition")

# Additional debugging: Check education distribution in final groups
base::cat("\n=== EDUCATION DISTRIBUTION IN FINAL GROUPS ===\n")

if (base::nrow(group_a_data) > 0) {
  base::cat("\nGroup A education codes:\n")
  edu_dist_a <- base::table(group_a_data$SCHL)
  
  edu_dist_a_df <- base::data.frame(
    SCHL_Code = base::names(head(base::sort(edu_dist_a, decreasing = TRUE), 10)),
    Count = base::as.numeric(head(base::sort(edu_dist_a, decreasing = TRUE), 10))
  )
  
  flextable::flextable(edu_dist_a_df) |>
    flextable::set_header_labels(
      SCHL_Code = "Education Code",
      count = "Count"
      ) |>
    flextable::add_header_lines(values = "Group A: Top 10 Education Codes") |>
    flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
    flextable::color(i = 1, color = "darkblue", part = "header") |>
    flextable::bold(i = 1:2, part = "header") |>
    flextable::bg(i = 2, bg = "palegreen", part = "header") |>
    ftExtra::colformat_md() |> 
    flextable::autofit()
}

if (base::nrow(group_b_data) > 0) {
  base::cat("\nGroup B education codes:\n")
  edu_dist_b <- base::table(group_b_data$SCHL)
  
  edu_dist_b_df <- base::data.frame(
    SCHL_Code = base::names(utils::head(base::sort(edu_dist_b, decreasing = TRUE), 10)),
    Count = base::as.numeric(utils::head(base::sort(edu_dist_b, decreasing = TRUE), 10))
  )
  
  flextable::flextable(edu_dist_b_df) |>
     flextable::set_header_labels(
      SCHL_Code = "Education Code",
      count = "Count"
      ) |>
    flextable::add_header_lines(values = "Group B: Top 10 Education Codes") |>
     flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
    flextable::color(i = 1, color = "darkblue", part = "header") |>
    flextable::bold(i = 1:2, part = "header") |>
    flextable::bg(i = 2, bg = "palegreen", part = "header") |>
    ftExtra::colformat_md() |> 
    flextable::autofit()
}

base::cat("================================\n")
```

# Educational Attainment Distribution

```{r education-distribution}
base::cat("\n### EDUCATIONAL ATTAINMENT ANALYSIS ###\n")

# Analyze education distribution for both groups
edu_distribution <- combined_data |>
  dplyr::group_by(group, SCHL_label) |>
  dplyr::summarise(count = dplyr::n(), .groups = "drop") |>
  dplyr::mutate(
    Group = base::ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
    Education = SCHL_label,
    Count = count
  ) |>
  dplyr::select(Group, Education, Count) |>
  dplyr::arrange(Group, dplyr::desc(Count))

base::cat("Total unique education levels found:", base::length(base::unique(edu_distribution$Education)), "\n")

# Display top education levels for each group
edu_top10 <- edu_distribution |>
  dplyr::group_by(Group) |>
  dplyr::slice_head(n = 10) |>
  dplyr::ungroup()

create_summary_table(edu_top10, "Top 10 Education Levels by Group")

# Debug: Show education distribution for filtered code
if (!base::is.null(GROUP_A_EDUCATION_CODE)) {
  base::cat("\nFiltered education for Group A (code", GROUP_A_EDUCATION_CODE, "):\n")
  filtered_edu_a <- edu_distribution |>
    dplyr::filter(Group == GROUP_A_LABEL)
  if (base::nrow(filtered_edu_a) > 0) {
    flextable::flextable(filtered_edu_a) |>
      flextable::add_header_lines(values = base::paste("Group A Education (Code", GROUP_A_EDUCATION_CODE, ")")) |>
      flextable::color(i = 1, color = "darkblue", part = "header") |>
      flextable::bold(i = 1, part = "header") |>
      flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
      flextable::bg(i = 2, bg = "palegreen", part = "header") |>
      flextable::autofit()
  } else {
    base::cat("No records found with specified education filter\n")
  }
}

if (!base::is.null(GROUP_B_EDUCATION_CODE)) {
  base::cat("\nFiltered education for Group B (code", GROUP_B_EDUCATION_CODE, "):\n")
  filtered_edu_b <- edu_distribution |>
    dplyr::filter(Group == GROUP_B_LABEL)
  if (base::nrow(filtered_edu_b) > 0) {
    flextable::flextable(filtered_edu_b) |>
      flextable::add_header_lines(values = base::paste("Group B Education (Code", GROUP_B_EDUCATION_CODE, ")")) |>
      flextable::color(i = 1, color = "darkblue", part = "header") |>
      flextable::bold(i = 1, part = "header") |>
      flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
      flextable::bg(i = 2, bg = "palegreen", part = "header") |>
      flextable::autofit()
  } else {
    base::cat("No records found with specified education filter\n")
  }
}

base::cat("================================\n")
```

# Explore Available Occupations (Optional)

```{r explore-occupations}
#| eval: false
# OPTIONAL: Run this chunk to explore occupations in your data
# Set eval: true above to include in report

# See top 20 most common occupations in the data
common_occupations <- explore_occupations(data = pums_data) |>
  dplyr::slice_head(n = 20) |>
  dplyr::mutate(OCCP_label = stringr::str_trunc(OCCP_label, 60))

base::cat("### Most Common Occupations in Dataset\n")

flextable::flextable(common_occupations) |>
  flextable::add_header_lines(values = "Most Common Occupations in Dataset") |>
  flextable::color(i = 1, color = "darkblue", part = "header") |>
  flextable::bold(i = 1, part = "header") |>
  flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
  flextable::bg(i = 2, bg = "palegreen", part = "header") |>
  flextable::autofit()

# Search for specific occupation terms
base::cat("\n### Search Example: All 'Manager' Occupations\n")
manager_occs <- explore_occupations("Manager", data = pums_data) |>
  dplyr::slice_head(n = 10)

flextable::flextable(manager_occs) |>
  flextable::add_header_lines(values = "Manager Occupations") |>
  flextable::color(i = 1, color = "darkblue", part = "header") |>
  flextable::bold(i = 1, part = "header") |>
  flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
  flextable::bg(i = 2, bg = "palegreen", part = "header") |>
  flextable::autofit()

# Search for healthcare occupations
base::cat("\n### Search Example: Healthcare Occupations\n")
health_occs <- explore_occupations("nurse|physician|doctor|medical", data = pums_data) |>
  dplyr::slice_head(n = 10)

flextable::flextable(health_occs) |>
  flextable::add_header_lines(values = "Healthcare Occupations") |>
  flextable::color(i = 1, color = "darkblue", part = "header") |>
  flextable::bold(i = 1, part = "header") |>
  flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
  flextable::bg(i = 2, bg = "palegreen", part = "header") |>
  flextable::autofit()
```

# Overall Pay Gap Analysis

```{r overall-analysis}
base::cat("\n### OVERALL PAY GAP ANALYSIS ###\n")
base::cat("Combined data size for analysis:", base::nrow(combined_data), "\n")

# Calculate overall pay gap
overall_gap <- calculate_pay_gap(combined_data)

if (!base::is.null(overall_gap)) {
  base::cat("Pay gap calculation successful\n")
  base::cat("Group A mean:", scales::dollar(overall_gap$group_a_mean), "\n")
  base::cat("Group B mean:", scales::dollar(overall_gap$group_b_mean), "\n")
  base::cat("Gap:", overall_gap$gap_percent, "%\n")
  
  # Create summary table
  overall_summary <- base::data.frame(
    Metric = base::c(
      base::paste(GROUP_A_LABEL, "Mean Earnings"),
      base::paste(GROUP_B_LABEL, "Mean Earnings"),
      "Pay Gap ($)",
      "Pay Gap (%)",
      "P-value",
      "Statistically Significant"
    ),
    Value = base::c(
      scales::dollar(overall_gap$group_a_mean),
      scales::dollar(overall_gap$group_b_mean),
      scales::dollar(overall_gap$gap_dollars),
      base::paste0(overall_gap$gap_percent, "%"),
      base::format(overall_gap$p_value, scientific = TRUE, digits = 3),
      base::ifelse(overall_gap$significant, "Yes", "No")
    ),
    stringsAsFactors = FALSE
  )
  
  create_summary_table(overall_summary, "Overall Pay Gap Analysis")
} else {
  base::cat("WARNING: Insufficient data for overall analysis\n")
  base::cat("Check that both groups have sufficient sample sizes\n")
}

base::cat("================================\n")
```

# Pay Gap by Education Level

```{r education-gap-analysis}
base::cat("\n### PAY GAP BY EDUCATION LEVEL ###\n")

# Analyze pay gaps by education level
edu_levels <- combined_data |>
  dplyr::group_by(SCHL_label) |>
  dplyr::summarise(total_count = dplyr::n(), .groups = "drop") |>
  dplyr::filter(total_count >= MIN_OCCUPATION_COUNT) |>
  dplyr::pull(SCHL_label)

base::cat("Education levels with sufficient sample size (>=", MIN_OCCUPATION_COUNT, "):", base::length(edu_levels), "\n")

edu_gap_results <- base::list()
for (edu in edu_levels) {
  edu_data <- combined_data |>
    dplyr::filter(SCHL_label == edu)
  
  # Skip if insufficient data
  if (base::nrow(edu_data) < 10) {
    base::cat("Skipping", edu, "- insufficient data (<10 records)\n")
    next
  }
  
  result <- calculate_pay_gap(edu_data)
  if (!base::is.null(result)) {
    edu_gap_results[[edu]] <- result
    base::cat("Analyzed:", edu, "\n")
  }
}

# Create summary table if results exist
if (base::length(edu_gap_results) > 0) {
  base::cat("\nSuccessfully analyzed", base::length(edu_gap_results), "education levels\n")
  
  edu_gap_summary <- base::data.frame(
    Education = base::names(edu_gap_results),
    GroupA_Count = base::sapply(edu_gap_results, function(x) base::round(x$group_a_count)),
    GroupB_Count = base::sapply(edu_gap_results, function(x) base::round(x$group_b_count)),
    GroupA_Mean = base::sapply(edu_gap_results, function(x) scales::dollar(x$group_a_mean)),
    GroupB_Mean = base::sapply(edu_gap_results, function(x) scales::dollar(x$group_b_mean)),
    Gap_Percent = base::sapply(edu_gap_results, function(x) base::paste0(x$gap_percent, "%")),
    Significant = base::sapply(edu_gap_results, function(x) 
      base::ifelse(x$significant, "Yes", "No")),
    stringsAsFactors = FALSE
  ) |>
    dplyr::mutate(Education = stringr::str_trunc(Education, 40))
  
  # Rename columns with actual group labels (using GrpA/GrpB to avoid duplicates)
  base::names(edu_gap_summary)[2:5] <- base::c(
    "GrpA_N",
    "GrpB_N",
    "GrpA_Mean",
    "GrpB_Mean"
  )
  
  create_summary_table(edu_gap_summary, "Pay Gap Analysis by Education Level")
} else {
  base::cat("WARNING: No education-specific results found with sufficient sample size\n")
}

base::cat("================================\n")
```

# Top Occupations Analysis

```{r top-occupations}
base::cat("\n### TOP OCCUPATIONS ANALYSIS ###\n")
base::cat("Analyzing top occupations for Group A\n")
base::cat("Group A sample size:", base::nrow(group_a_data), "\n")

# Analyze top occupations for Group A - WITH ERROR HANDLING
top_occupations <- base::tryCatch({
  base::cat("Attempting survey-weighted analysis...\n")
  # Try survey-weighted analysis
  result <- group_a_data |>
    srvyr::as_survey_design(weights = PWGTP) |>
    dplyr::group_by(OCCP_label) |>
    dplyr::summarise(
      count = srvyr::survey_total(),
      mean_earnings = srvyr::survey_mean(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) |>
    dplyr::filter(count >= MIN_OCCUPATION_COUNT) |>
    dplyr::arrange(dplyr::desc(mean_earnings)) |>
    dplyr::slice_head(n = TOP_N_OCCUPATIONS)
  base::cat("Survey-weighted analysis successful\n")
  result
}, error = function(e) {
  base::cat("Survey-weighted analysis failed, using unweighted analysis\n")
  base::cat("Error:", e$message, "\n")
  # Fall back to unweighted analysis
  group_a_data |>
    dplyr::group_by(OCCP_label) |>
    dplyr::summarise(
      count = dplyr::n(),
      mean_earnings = base::mean(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) |>
    dplyr::filter(count >= MIN_OCCUPATION_COUNT) |>
    dplyr::arrange(dplyr::desc(mean_earnings)) |>
    dplyr::slice_head(n = TOP_N_OCCUPATIONS)
})

# Format for display
if (base::nrow(top_occupations) > 0) {
  base::cat("Found", base::nrow(top_occupations), "occupations with sufficient sample size\n")
  
  top_occ_display <- top_occupations |>
    dplyr::mutate(
      Occupation = OCCP_label,
      `Sample Size` = base::round(count),
      `Mean Earnings` = scales::dollar(mean_earnings)
    ) |>
    dplyr::select(Occupation, `Sample Size`, `Mean Earnings`)
  
  create_summary_table(top_occ_display, 
                      base::paste("Top", TOP_N_OCCUPATIONS, "Occupations by Mean Earnings -", GROUP_A_LABEL))
} else {
  base::cat("WARNING: Insufficient data for top occupations analysis\n")
}

base::cat("================================\n")
```

# Visualization: Top Occupations

```{r top-occupations-plot}
#| fig-cap: "Top Occupations by Mean Earnings"

base::cat("\n### TOP OCCUPATIONS VISUALIZATION ###\n")

# Create bar plot only if we have data
if (base::exists("top_occupations") && base::nrow(top_occupations) > 0) {
  base::cat("Creating visualization with", base::min(10, base::nrow(top_occupations)), "occupations\n")
  
  top_10_plot <- top_occupations |>
    dplyr::slice_head(n = 10) |>
    dplyr::mutate(OCCP_label = forcats::fct_reorder(OCCP_label, mean_earnings)) |>
    ggplot2::ggplot(ggplot2::aes(x = mean_earnings, y = OCCP_label)) +
    ggplot2::geom_col(fill = "steelblue", alpha = 0.8) +
    ggplot2::scale_x_continuous(labels = scales::dollar_format()) +
    ggplot2::labs(
      title = base::paste("Top 10 Occupations:", GROUP_A_LABEL),
      subtitle = base::paste(STATE_CODE, "- Ages", AGE_MIN, "to", AGE_MAX),
      x = "Mean Annual Earnings",
      y = NULL
    ) +
    ggplot2::theme_minimal() +
    ggplot2::theme(
      plot.title = ggplot2::element_text(size = 14, face = "bold"),
      axis.text.y = ggplot2::element_text(size = 10)
    )
  
  base::print(top_10_plot)
} else {
  base::cat("WARNING: Insufficient data for visualization\n")
}

base::cat("================================\n")
```

# Occupation-Specific Pay Gap Analysis

```{r occupation-gaps}
base::cat("\n### OCCUPATION-SPECIFIC PAY GAP ANALYSIS ###\n")

# Test occupations from parameters
test_occupations <- OCCUPATION_GAP_ANALYSIS
base::cat("Testing", base::length(test_occupations), "occupation categories\n")

occupation_results <- base::list()
for (occ in test_occupations) {
  base::cat("Analyzing:", occ, "... ")
  result <- calculate_pay_gap(combined_data, occ)
  if (!base::is.null(result)) {
    occupation_results[[occ]] <- result
    base::cat("Success (n=", base::round(result$group_a_count + result$group_b_count), ")\n")
  } else {
    base::cat("Insufficient data\n")
  }
}

# Create summary table if results exist
if (base::length(occupation_results) > 0) {
  base::cat("\nSuccessfully analyzed", base::length(occupation_results), "occupations\n")
  
  occ_summary <- base::data.frame(
    Occupation = base::names(occupation_results),
    GroupA_Count = base::sapply(occupation_results, function(x) base::round(x$group_a_count)),
    GroupB_Count = base::sapply(occupation_results, function(x) base::round(x$group_b_count)),
    Gap_Percent = base::sapply(occupation_results, function(x) base::paste0(x$gap_percent, "%")),
    P_Value = base::sapply(occupation_results, function(x) 
      base::ifelse(base::is.na(x$p_value), "N/A", base::format(x$p_value, digits = 3))),
    Significant = base::sapply(occupation_results, function(x) 
      base::ifelse(x$significant, "Yes", "No")),
    stringsAsFactors = FALSE
  )
  
  # Rename columns with actual group labels (using GrpA/GrpB to avoid duplicates)
  base::names(occ_summary)[2:3] <- base::c(
    "GrpA_N",
    "GrpB_N"
  )
  
  create_summary_table(occ_summary, "Pay Gap Analysis by Occupation")
} else {
  base::cat("WARNING: No occupation-specific results found with sufficient sample size\n")
}

base::cat("================================\n")
```

# Custom Occupation Search

```{r occupation-search}
base::cat("\n### CUSTOM OCCUPATION SEARCH ###\n")

# Example searches from parameters
example_searches <- OCCUPATION_SEARCH_EXAMPLES

base::cat("Performing", base::length(example_searches), "example searches\n\n")

for (term in example_searches) {
  base::cat("**Searching for:", term, "**\n")
  results <- search_occupation(term)
  
  if (!base::is.null(results)) {
    base::cat("Found", base::nrow(results), "matching occupations\n")
    
    flextable::flextable(results) |>
      flextable::add_header_lines(values = base::paste("Search Results:", term)) |>
      flextable::color(i = 1, color = "darkblue", part = "header") |>
      flextable::bold(i = 1, part = "header") |>
      flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
      flextable::bg(i = 2, bg = "palegreen", part = "header") |>
      flextable::autofit() |>
      base::print()
    
    base::cat("\n")
  } else {
    base::cat("No results found (insufficient data)\n\n")
  }
}

base::cat("================================\n")
```

# Summary Statistics

```{r summary-stats}
base::cat("\n### SUMMARY STATISTICS ###\n")

# Calculate summary statistics for both groups including education - WITH ERROR HANDLING
summary_stats <- base::tryCatch({
  base::cat("Attempting survey-weighted summary statistics...\n")
  # Try survey-weighted analysis
  result <- combined_data |>
    srvyr::as_survey_design(weights = PWGTP) |>
    dplyr::group_by(group) |>
    dplyr::summarise(
      n = srvyr::survey_total(),
      mean_age = srvyr::survey_mean(AGEP, na.rm = TRUE),
      mean_earnings = srvyr::survey_mean(PERNP, na.rm = TRUE),
      median_earnings = srvyr::survey_median(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) |>
    dplyr::mutate(
      Group = base::ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
      `Sample Size` = base::round(n),
      `Mean Age` = base::round(mean_age, 1),
      `Mean Earnings` = scales::dollar(mean_earnings),
      `Median Earnings` = scales::dollar(median_earnings)
    ) |>
    dplyr::select(Group, `Sample Size`, `Mean Age`, `Mean Earnings`, `Median Earnings`)
  base::cat("Survey-weighted statistics calculated successfully\n")
  result
}, error = function(e) {
  base::cat("Survey-weighted analysis failed, using unweighted statistics\n")
  base::cat("Error:", e$message, "\n")
  # Fall back to unweighted analysis
  combined_data |>
    dplyr::group_by(group) |>
    dplyr::summarise(
      n = dplyr::n(),
      mean_age = base::mean(AGEP, na.rm = TRUE),
      mean_earnings = base::mean(PERNP, na.rm = TRUE),
      median_earnings = stats::median(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) |>
    dplyr::mutate(
      Group = base::ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
      `Sample Size` = n,
      `Mean Age` = base::round(mean_age, 1),
      `Mean Earnings` = scales::dollar(mean_earnings),
      `Median Earnings` = scales::dollar(median_earnings)
    ) |>
    dplyr::select(Group, `Sample Size`, `Mean Age`, `Mean Earnings`, `Median Earnings`)
})

create_summary_table(summary_stats, "Summary Statistics by Group")

# Education level summary
base::cat("\nCalculating education level percentages...\n")
edu_stats <- combined_data |>
  dplyr::group_by(group) |>
  dplyr::summarise(
    bachelor_plus = base::mean(SCHL >= "21", na.rm = TRUE) * 100,
    masters_plus = base::mean(SCHL >= "22", na.rm = TRUE) * 100,
    doctorate = base::mean(SCHL == "24", na.rm = TRUE) * 100,
    .groups = "drop"
  ) |>
  dplyr::mutate(
    Group = base::ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
    `Bachelor's or Higher (%)` = base::round(bachelor_plus, 1),
    `Master's or Higher (%)` = base::round(masters_plus, 1),
    `Doctorate (%)` = base::round(doctorate, 1)
  ) |>
  dplyr::select(Group, `Bachelor's or Higher (%)`, `Master's or Higher (%)`, `Doctorate (%)`)

create_summary_table(edu_stats, "Educational Attainment by Group")

base::cat("================================\n")
```

# Debug Summary

```{r debug-summary}
base::cat("\n### FINAL DEBUG SUMMARY ###\n")
base::cat("=====================================\n")

# Create final summary
debug_summary <- base::data.frame(
  Stage = base::c(
    "Raw Data Downloaded",
    "After Basic Filters (Group A)",
    "After Education Filter (Group A)",
    "After Basic Filters (Group B)",
    "After Education Filter (Group B)",
    "Combined Dataset"
  ),
  Sample_Size = base::c(
    base::nrow(pums_data),
    NA,
    base::nrow(group_a_data),
    NA,
    base::nrow(group_b_data),
    base::nrow(combined_data)
  ),
  stringsAsFactors = FALSE
)

# Display parameters used as flextable
params_df <- base::data.frame(
  Parameter = base::c("State", "Year", "Age Range", 
                      "Group A Sex", "Group A Marital", "Group A Education",
                      "Group B Sex", "Group B Marital", "Group B Education"),
  Value = base::c(
    STATE_CODE,
    base::as.character(SURVEY_YEAR),
    base::paste0(AGE_MIN, "-", AGE_MAX),
    GROUP_A_SEX,
    base::ifelse(base::is.null(GROUP_A_MAR), "All", GROUP_A_MAR),
    base::ifelse(base::is.null(GROUP_A_EDUCATION_CODE), "All", base::as.character(GROUP_A_EDUCATION_CODE)),
    GROUP_B_SEX,
    base::ifelse(base::is.null(GROUP_B_MAR), "All", GROUP_B_MAR),
    base::ifelse(base::is.null(GROUP_B_EDUCATION_CODE), "All", base::as.character(GROUP_B_EDUCATION_CODE))
  ),
  stringsAsFactors = FALSE
)

flextable::flextable(params_df) |>
  flextable::add_header_lines(values = "Parameters Used") |>
  flextable::color(i = 1, color = "darkblue", part = "header") |>
  flextable::bold(i = 1, part = "header") |>
  flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
  flextable::bg(i = 2, bg = "palegreen", part = "header") |>
  flextable::autofit()

# Final sample sizes as flextable
final_sizes_df <- base::data.frame(
  Group = base::c("Group A", "Group B", "Combined"),
  Label = base::c(GROUP_A_LABEL, GROUP_B_LABEL, "Total"),
  Sample_Size = base::c(base::nrow(group_a_data), base::nrow(group_b_data), base::nrow(combined_data)),
  stringsAsFactors = FALSE
)

flextable::flextable(final_sizes_df) |>
  flextable::add_header_lines(values = "Final Sample Sizes") |>
  flextable::color(i = 1, color = "darkblue", part = "header") |>
  flextable::bold(i = 1, part = "header") |>
  flextable::bg(i = 1, bg = "lightyellow", part = "header") |>
  flextable::bg(i = 2, bg = "palegreen", part = "header") |>
  flextable::autofit()

if (base::nrow(group_a_data) == 0 || base::nrow(group_b_data) == 0) {
  base::cat("\n WARNING: One or both groups have zero records!\n")
  base::cat("Check that:\n")
  base::cat("1. Education code exists in the data\n")
  base::cat("2. Data types match (numeric vs character)\n")
  base::cat("3. Combination of filters doesn't exclude all records\n")
}

base::cat("=====================================\n")
```

# Methods

This analysis uses American Community Survey (ACS) 5-year Public Use Microdata Sample (PUMS) data from `r SURVEY_YEAR`. 

**Analysis Parameters:**
- Geographic Area: `r STATE_CODE`
- Age Range: `r AGE_MIN` to `r AGE_MAX`
- Group A: `r GROUP_A_LABEL`
  - Education Filter: `r base::ifelse(!base::is.null(GROUP_A_EDUCATION_CODE), base::paste("Code:", base::paste(GROUP_A_EDUCATION_CODE, collapse=",")), base::ifelse(!base::is.null(GROUP_A_EDUCATION_LABEL), base::paste("Label:", GROUP_A_EDUCATION_LABEL), "All education levels"))`
- Group B: `r GROUP_B_LABEL`
  - Education Filter: `r base::ifelse(!base::is.null(GROUP_B_EDUCATION_CODE), base::paste("Code:", base::paste(GROUP_B_EDUCATION_CODE, collapse=",")), base::ifelse(!base::is.null(GROUP_B_EDUCATION_LABEL), base::paste("Label:", GROUP_B_EDUCATION_LABEL), "All education levels"))`
- Minimum Education Level: `r base::ifelse(!base::is.null(MIN_EDUCATION_CODE), base::paste("Code", MIN_EDUCATION_CODE, "and above"), "None")`
- Minimum occupation sample size: `r MIN_OCCUPATION_COUNT`

**Statistical Methods:**
- All estimates use survey weights to account for complex sampling design
- Pay gaps calculated as: (Group B earnings - Group A earnings) / Group A earnings  100
- Statistical significance tested using survey-weighted t-tests ( = 0.05)
- Mean earnings used as primary measure to capture full earnings distribution
- Educational attainment analyzed using SCHL variable from ACS PUMS
- **Note:** When sample sizes are too small for survey-weighted analysis, the template automatically falls back to unweighted statistics to prevent errors

**Education Codes Reference:**
- 16: Regular high school diploma
- 18: Some college, but less than 1 year
- 21: Bachelor's degree
- 22: Master's degree
- 23: Professional degree beyond bachelor's
- 24: Doctorate degree



# Cache Information

```{r cache-info}
base::cat("\n### CACHE INFORMATION ###\n")

# Display cache files
cache_files <- base::list.files("cache_data", pattern = CACHE_PREFIX, full.names = TRUE)

if (base::length(cache_files) > 0) {
  base::cat("Found", base::length(cache_files), "cache files\n")
  
  cache_info <- base::file.info(cache_files)
  cache_summary <- base::data.frame(
    File = base::basename(cache_files),
    Size_MB = base::round(cache_info$size / 1024^2, 2),
    Modified = base::format(cache_info$mtime, "%Y-%m-%d %H:%M"),
    stringsAsFactors = FALSE
  )
  
  create_summary_table(cache_summary, "Cache Files")
  
  base::cat("\nTo refresh data: Set FORCE_REFRESH <- TRUE or delete cache files\n")
} else {
  base::cat("No cache files found for this analysis\n")
  base::cat("Data will be downloaded fresh on next run\n")
}

base::cat("================================\n")

```

---

*Report generated on `r base::format(base::Sys.Date(), "%B %d, %Y")` using R and Quarto*  
*Template Version: 2.2 - Enhanced with Comprehensive Debugging*


