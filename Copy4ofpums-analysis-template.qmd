---
title: "PUMS Pay Gap Analysis Template"
subtitle: "Enhanced Template with Educational Attainment Filtering"
description: "Using ACS5 database with education level parameters"
author: 
  - name: "Dan Swart, CPA (ret)"
    affiliations:
      - "SCUC-ISD Board of Trustees"
      - "Seat 6"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # Hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: true
    include-in-header: header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 14pt
    mainfont: "Cabin"
    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px



  # docx:
  #   highlight-style: github
  #   fig_caption: true



editor: source

quarto:
  render:
    cache-refresh: true


# for .qmd filesd
execute:
  echo: true
  message: false
  warning: false
  eval: true
  fig-width: 12
  fig-height: 10


# for .rmd files
knitr:
  opts_chunk:
    echo: true
    error: false
    warning: false
    message: false
    cache: false
    fig.width: 12
    fig.height: 10


---


```{r}
#| label: setup
#| include: false

# Prevent scientific notation globally
options(scipen = 999)

options(tigris_use_cache = TRUE)

# install.packages(c("mapview", "survey", "srvyr", "arcgislayers"))

# census_api_key("95496766c51541ee6f402c1e1a8658581285b759", install = TRUE, overwrite = TRUE)


# load libraries

library(tidyverse)
library(tidycensus)
library(dplyr)
library(survey)
library(srvyr)
library(stringr)
library(knitr)
library(DT)
library(ggplot2)
library(scales)
library(forcats)


# Force dplyr's select to take precedence
select <- dplyr::select
filter <- dplyr::filter

# Create cache directory
if (!dir.exists("cache_data")) {
  dir.create("cache_data")
}

# Set default chunk options
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 12,
  fig.height = 10
)

# Set global theme for consistent plots
theme_set(theme_minimal(base_size = 20) + 
          theme(
    plot.title = element_text(face = "bold", size = 26),    # adjust title size
    plot.subtitle = element_text(face = "bold", size = 24), # adjust subtitle size
    axis.title.x = element_text(face = "bold", size = 22),
    axis.title.y = element_text(face = "bold", size = 22),
    axis.text.x = element_text(face = "bold", size = 22, angle = 45, hjust = 1),
    legend.position = "bottom",
    strip.text = element_text(face = "bold"),
    panel.spacing.x = unit(1.5, "cm"),  # Horizontal spacing only
    panel.spacing.y = unit(1.5, "cm"),   # Vertical spacing only
    plot.margin = margin(20, 20, 20, 20, "pt")
    )
)


# Set seed for reproducibility
set.seed(123)

```


<!-- 
================================================================================
                        MODIFICATION INSTRUCTIONS
================================================================================

This template analyzes pay gaps between two demographic groups using PUMS data.
To adapt for your research, modify the ANALYSIS PARAMETERS section below.

STEP 1: DEFINE YOUR GROUPS
------------------------
- Group A and Group B can be any combination of sex, marital status, and education level
- Use tidycensus::pums_variables to find exact codes:
  > library(tidycensus)
  > View(pums_variables)
  > Search for SEX, MAR, SCHL, or other variables

Common codes:
- SEX: "1" = Male, "2" = Female  
- MAR: "1" = Married, "2" = Widowed, "3" = Divorced, "4" = Separated, "5" = Never married
- SCHL: Common education levels:
  * "16" = Regular high school diploma
  * "18" = Some college, but less than 1 year
  * "21" = Bachelor's degree
  * "22" = Master's degree
  * "23" = Professional degree beyond bachelor's
  * "24" = Doctorate degree

EDUCATIONAL ATTAINMENT FILTERING:
------------------------
You can filter by:
1. Specific education code: e.g., "23" for professional degree
2. Multiple codes: c("22", "23", "24") for graduate degrees
3. Education labels using regex: "Bachelor|Master" 
4. NULL to include all education levels

FINDING OCCUPATIONS:
------------------------
Occupations use partial text matching on OCCP_label field. To find occupations:
  > library(tidycensus)
  > pums_vars <- pums_variables
  > View(pums_vars %>% filter(var_code == "OCCP"))  # See all occupation labels
  
Example: "Manager" matches all manager types, "Nurse" matches all nursing occupations
For specific occupations, use more precise terms (e.g., "Registered nurses" vs "Nurse")

STEP 2: UPDATE PARAMETERS
------------------------
Edit the ANALYSIS PARAMETERS section below with your values

STEP 3: UPDATE REPORT TEXT
------------------------
Search and replace the group labels throughout the document

STEP 4: CLEAR CACHE (if changing data parameters)
------------------------
Delete the cache_data folder to force fresh data download

STEP 5: RENDER
------------------------
Click "Render" in RStudio or run: quarto render yourfile.qmd

================================================================================
-->

<!-- # Un-comment to look for PUMS education Codes -->

```{r pums-education-codes}

# # Load all variables available in PUMS
# View(tidycensus::pums_variables)
# 
# # View education codes specifically
# education_codes <- tidycensus::pums_variables %>%
#   filter(var_code == "SCHL", survey == "acs5", year == 2023) %>%
#   select(val_label)
# View(education_codes)

```


# ANALYSIS PARAMETERS {.unnumbered}

**Modify these parameters for your specific analysis:**

```{r parameters}
# ============================================
#           MAIN ANALYSIS PARAMETERS
# ============================================

# Geographic and time parameters
STATE_CODE <- "TX"           # State abbreviation
SURVEY_YEAR <- 2023          # Year of ACS data
AGE_MIN <- 40                # Minimum age
AGE_MAX <- 64                # Maximum age

# ============================================
#        EDUCATIONAL ATTAINMENT FILTERS
# ============================================
# Use NULL to include all education levels, or specify codes/labels

# Option 1: Filter by specific education code(s)
# Single code: "23" for professional degree
# Multiple codes: c("21", "22", "23", "24") for bachelor's and above
# NULL for all education levels

GROUP_A_EDUCATION_CODE <- 23  # NULL or a code like "23" for professional degree
GROUP_B_EDUCATION_CODE <- 23  # NULL or a code like c("21", "22") for bachelor's/master's

# Option 2: Filter by education label pattern (regex)
# Examples: "Bachelor", "Master|Professional", "degree"
# NULL to not filter by label

GROUP_A_EDUCATION_LABEL <- NULL  # Example: "Professional degree"
GROUP_B_EDUCATION_LABEL <- NULL  # Example: "Bachelor|Master"

# Minimum education level (optional)
# Filters to include only this code and higher
# Common thresholds: "16" (HS), "21" (Bachelor's), "22" (Master's)
MIN_EDUCATION_CODE <- NULL  # Example: "21" for bachelor's and above

# ============================================
#           GROUP DEFINITIONS
# ============================================

# Group A definition
GROUP_A_SEX <- "2"           # "1" = Male, "2" = Female
GROUP_A_MAR <- "5"           # "5" = Never married, NULL = all marital statuses
GROUP_A_LABEL <- "Never-Married Females"  # Display label for Group A

# Group B definition
GROUP_B_SEX <- "1"           # "1" = Male, "2" = Female  
GROUP_B_MAR <- "5"           # NULL = all marital statuses, or specify code
GROUP_B_LABEL <- "Never-Married Males" # Display label for Group B

# Analysis options
MIN_OCCUPATION_COUNT <- 30   # Minimum sample size for occupation analysis
TOP_N_OCCUPATIONS <- 20      # Number of top occupations to display

# Occupations to analyze for pay gaps (partial text matching)
OCCUPATION_GAP_ANALYSIS <- c("MED-Physicians", "MED-Surgeons", "MED-Dentists", "MED-Pharmacists", "LGL-Lawyers, And Judges, Magistrates, And Other Judicial Workers
T", "EDU-Postsecondary Teachers", "MGR-General And Operations Managers", "EDU-Secondary School Teachers", "MED-Registered Nurses", "ENG-Engineer", "FIN-Accountants And Auditors
", "MGR-Sales Managers")

# Additional occupations for detailed search examples
OCCUPATION_SEARCH_EXAMPLES <- c("Clerk", "Driver")

# Note: These use partial matching. "Manager" matches all manager occupations.
# For specific occupations, use precise terms like "General and operations managers"

# Cache management
CACHE_PREFIX <- "nm_fem_vs_nm_male_edu"  # Unique prefix for cache files
FORCE_REFRESH <- FALSE       # Set TRUE to ignore cache and download fresh data

# ============================================
#           DERIVED PARAMETERS
# ============================================

# Create unique cache paths based on parameters
cache_raw <- paste0("cache_data/", CACHE_PREFIX, "_raw.rds")
cache_processed <- paste0("cache_data/", CACHE_PREFIX, "_processed.rds")
cache_analysis <- paste0("cache_data/", CACHE_PREFIX, "_analysis.rds")

# Create analysis description
education_desc_a <- if(!is.null(GROUP_A_EDUCATION_CODE)) {
  paste0(" (Edu: ", paste(GROUP_A_EDUCATION_CODE, collapse = ","), ")")
} else if(!is.null(GROUP_A_EDUCATION_LABEL)) {
  paste0(" (Edu: ", GROUP_A_EDUCATION_LABEL, ")")
} else if(!is.null(MIN_EDUCATION_CODE)) {
  paste0(" (Edu >= ", MIN_EDUCATION_CODE, ")")
} else ""

education_desc_b <- if(!is.null(GROUP_B_EDUCATION_CODE)) {
  paste0(" (Edu: ", paste(GROUP_B_EDUCATION_CODE, collapse = ","), ")")
} else if(!is.null(GROUP_B_EDUCATION_LABEL)) {
  paste0(" (Edu: ", GROUP_B_EDUCATION_LABEL, ")")
} else if(!is.null(MIN_EDUCATION_CODE)) {
  paste0(" (Edu >= ", MIN_EDUCATION_CODE, ")")
} else ""

ANALYSIS_DESCRIPTION <- paste0(
  "Comparing ", GROUP_A_LABEL, education_desc_a, 
  " vs ", GROUP_B_LABEL, education_desc_b,
  " in ", STATE_CODE, " (Ages ", AGE_MIN, "-", AGE_MAX, ")"
)

cat("Analysis Configuration:\n")
cat("====================\n")
cat(ANALYSIS_DESCRIPTION, "\n")
cat("Data Year:", SURVEY_YEAR, "\n")
cat("Cache Prefix:", CACHE_PREFIX, "\n\n")
```

# Data Functions

```{r functions}

# Enhanced function to filter PUMS data with education parameters
filter_pums_data <- function(data, sex_code, mar_code = NULL, 
                            edu_code = NULL, edu_label = NULL,
                            min_edu = MIN_EDUCATION_CODE,
                            age_min = AGE_MIN, age_max = AGE_MAX) {
  
  result <- data %>%
    filter(
      SEX == sex_code,
      AGEP >= age_min & AGEP <= age_max,
      PERNP > 0,               # Has earnings
      OCCP != "000N",          # Valid occupation
      !is.na(OCCP),
      !is.na(PERNP)
    )
  
  # Apply marital status filter if specified
  if (!is.null(mar_code)) {
    result <- result %>% filter(MAR == mar_code)
  }
  
  # Apply education code filter if specified
  if (!is.null(edu_code)) {
    if (length(edu_code) == 1) {
      result <- result %>% filter(SCHL == edu_code)
    } else {
      result <- result %>% filter(SCHL %in% edu_code)
    }
  }
  
  # Apply education label filter if specified
  if (!is.null(edu_label)) {
    result <- result %>% 
      filter(str_detect(SCHL_label, regex(edu_label, ignore_case = TRUE)))
  }
  
  # Apply minimum education filter if specified
  if (!is.null(min_edu)) {
    result <- result %>% filter(SCHL >= min_edu)
  }
  
  return(result)
}

# Function to calculate pay gap with statistical testing
calculate_pay_gap <- function(data, occupation_filter = NULL) {
  
  # Apply occupation filter if specified
  if (!is.null(occupation_filter)) {
    data <- data %>%
      filter(str_detect(OCCP_label, regex(occupation_filter, ignore_case = TRUE)))
  }
  
  # Check for sufficient data
  if (nrow(data) < 10) return(NULL)
  
  # Check both groups are present
  groups <- unique(data$group)
  if (length(groups) < 2) return(NULL)
  
  # Calculate weighted statistics
  svy_data <- data %>% as_survey_design(weights = PWGTP)
  
  group_stats <- svy_data %>%
    group_by(group) %>%
    summarise(
      count = survey_total(),
      mean_earnings = survey_mean(PERNP, na.rm = TRUE),
      median_earnings = survey_median(PERNP, na.rm = TRUE),
      .groups = "drop"
    )
  
  # Calculate gap (Group B - Group A)
  group_a_stats <- filter(group_stats, group == "Group_A")
  group_b_stats <- filter(group_stats, group == "Group_B")
  
  if (nrow(group_a_stats) == 0 || nrow(group_b_stats) == 0) return(NULL)
  
  gap_dollars <- group_b_stats$mean_earnings - group_a_stats$mean_earnings
  gap_percent <- (gap_dollars / group_a_stats$mean_earnings) * 100
  
  # Statistical test
  p_value <- tryCatch({
    test <- svyttest(PERNP ~ group, svy_data)
    test$p.value
  }, error = function(e) NA)
  
  return(list(
    occupation = ifelse(is.null(occupation_filter), "All Occupations", occupation_filter),
    group_a_mean = group_a_stats$mean_earnings,
    group_b_mean = group_b_stats$mean_earnings,
    gap_dollars = gap_dollars,
    gap_percent = round(gap_percent, 1),
    p_value = p_value,
    significant = !is.na(p_value) && p_value < 0.05,
    group_a_count = group_a_stats$count,
    group_b_count = group_b_stats$count
  ))
}

# Function to create formatted tables
create_summary_table <- function(data, title = NULL) {
  if (knitr::is_html_output()) {
    datatable(data, caption = title, options = list(pageLength = 10))
  } else {
    knitr::kable(data, caption = title, format = "simple")
  }
}

# Helper function to explore available occupations in the data
explore_occupations <- function(search_term = NULL, data = pums_data) {
  # Get unique occupations with counts
  occ_summary <- data %>%
    filter(!is.na(OCCP_label), OCCP != "000N") %>%
    group_by(OCCP, OCCP_label) %>%
    summarise(count = n(), .groups = "drop") %>%
    arrange(desc(count))
  
  # Filter if search term provided
  if (!is.null(search_term)) {
    occ_summary <- occ_summary %>%
      filter(str_detect(OCCP_label, regex(search_term, ignore_case = TRUE)))
  }
  
  return(occ_summary)
}

# New function to explore education levels in the data
explore_education <- function(data = pums_data) {
  edu_summary <- data %>%
    filter(!is.na(SCHL_label)) %>%
    group_by(SCHL, SCHL_label) %>%
    summarise(
      count = n(),
      mean_earnings = mean(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    arrange(SCHL)
  
  return(edu_summary)
}
```

# Data Collection

```{r data-collection}
#| cache: true

# Check cache or download fresh data
if (!FORCE_REFRESH && file.exists(cache_raw)) {
  cat("Loading cached data...\n")
  pums_data <- readRDS(cache_raw)
} else {
  cat("Downloading PUMS data from Census API...\n")
  cat("This may take several minutes...\n\n")
  
  # Download PUMS data with SCHL (educational attainment) added
  invisible(capture.output(
    pums_data <- get_pums(
      variables = c("SEX", "MAR", "SCHL", "OCCP", "PINCP", "PERNP", "AGEP", "COW"),
      state = STATE_CODE,
      survey = "acs5",
      year = SURVEY_YEAR,
      recode = TRUE
    )
  ))
  
  # Save to cache
  saveRDS(pums_data, cache_raw)
  cat("Data downloaded and cached.\n")
}

cat("Total records downloaded:", nrow(pums_data), "\n")
```

# Data Processing

```{r data-processing}
#| cache: true

# Check cache or process data
if (!FORCE_REFRESH && file.exists(cache_processed)) {
  cat("Loading cached processed data...\n")
  processed_data <- readRDS(cache_processed)
  group_a_data <- processed_data$group_a
  group_b_data <- processed_data$group_b
  combined_data <- processed_data$combined
} else {
  cat("Processing data...\n")
  
  # Filter Group A with education parameters
  group_a_data <- filter_pums_data(
    pums_data, 
    GROUP_A_SEX, 
    GROUP_A_MAR,
    edu_code = GROUP_A_EDUCATION_CODE,
    edu_label = GROUP_A_EDUCATION_LABEL
  )
  cat("Group A (", GROUP_A_LABEL, "): ", nrow(group_a_data), " records\n", sep = "")
  
  # Filter Group B with education parameters
  group_b_data <- filter_pums_data(
    pums_data, 
    GROUP_B_SEX, 
    GROUP_B_MAR,
    edu_code = GROUP_B_EDUCATION_CODE,
    edu_label = GROUP_B_EDUCATION_LABEL
  )
  cat("Group B (", GROUP_B_LABEL, "): ", nrow(group_b_data), " records\n", sep = "")
  
  # Combine with group labels
  combined_data <- bind_rows(
    group_a_data %>% mutate(group = "Group_A"),
    group_b_data %>% mutate(group = "Group_B")
  )
  
  # Save processed data
  processed_data <- list(
    group_a = group_a_data,
    group_b = group_b_data,
    combined = combined_data
  )
  saveRDS(processed_data, cache_processed)
  cat("Data processed and cached.\n")
}

# Display sample summary
sample_summary <- data.frame(
  Group = c(GROUP_A_LABEL, GROUP_B_LABEL),
  `Sample Size` = c(nrow(group_a_data), nrow(group_b_data)),
  `Age Range` = paste0(AGE_MIN, "-", AGE_MAX),
  stringsAsFactors = FALSE
)

create_summary_table(sample_summary, "Sample Composition")
```

# Educational Attainment Distribution

```{r education-distribution}
# Analyze education distribution for both groups
edu_distribution <- combined_data %>%
  group_by(group, SCHL_label) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(
    Group = ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
    Education = SCHL_label,
    Count = count
  ) %>%
  select(Group, Education, Count) %>%
  arrange(Group, desc(Count))

# Display top education levels for each group
edu_top10 <- edu_distribution %>%
  group_by(Group) %>%
  slice_head(n = 10) %>%
  ungroup()

create_summary_table(edu_top10, "Top 10 Education Levels by Group")
```

# Explore Available Occupations (Optional)

```{r explore-occupations}
#| eval: false
# OPTIONAL: Run this chunk to explore occupations in your data
# Set eval: true above to include in report

# See top 20 most common occupations in the data
common_occupations <- explore_occupations(data = pums_data) %>%
  slice_head(n = 20) %>%
  mutate(OCCP_label = str_trunc(OCCP_label, 60))  # Truncate long names

cat("### Most Common Occupations in Dataset\n")
print(knitr::kable(common_occupations, format = "pipe"))

# Search for specific occupation terms
cat("\n### Search Example: All 'Manager' Occupations\n")
manager_occs <- explore_occupations("Manager", data = pums_data) %>%
  slice_head(n = 10)
print(knitr::kable(manager_occs, format = "pipe"))

# Search for healthcare occupations
cat("\n### Search Example: Healthcare Occupations\n")
health_occs <- explore_occupations("nurse|physician|doctor|medical", data = pums_data) %>%
  slice_head(n = 10)
print(knitr::kable(health_occs, format = "pipe"))
```

# Overall Pay Gap Analysis

```{r overall-analysis}
# Calculate overall pay gap
overall_gap <- calculate_pay_gap(combined_data)

if (!is.null(overall_gap)) {
  # Create summary table
  overall_summary <- data.frame(
    Metric = c(
      paste(GROUP_A_LABEL, "Mean Earnings"),
      paste(GROUP_B_LABEL, "Mean Earnings"),
      "Pay Gap ($)",
      "Pay Gap (%)",
      "P-value",
      "Statistically Significant"
    ),
    Value = c(
      dollar(overall_gap$group_a_mean),
      dollar(overall_gap$group_b_mean),
      dollar(overall_gap$gap_dollars),
      paste0(overall_gap$gap_percent, "%"),
      format(overall_gap$p_value, scientific = TRUE, digits = 3),
      ifelse(overall_gap$significant, "Yes", "No")
    ),
    stringsAsFactors = FALSE
  )
  
  create_summary_table(overall_summary, "Overall Pay Gap Analysis")
} else {
  cat("Insufficient data for overall analysis.\n")
}
```

# Pay Gap by Education Level

```{r education-gap-analysis}
# Analyze pay gaps by education level
edu_levels <- combined_data %>%
  group_by(SCHL_label) %>%
  summarise(total_count = n(), .groups = "drop") %>%
  filter(total_count >= MIN_OCCUPATION_COUNT) %>%
  pull(SCHL_label)

edu_gap_results <- list()
for (edu in edu_levels) {
  edu_data <- combined_data %>%
    filter(SCHL_label == edu)
  
  result <- calculate_pay_gap(edu_data)
  if (!is.null(result)) {
    edu_gap_results[[edu]] <- result
  }
}

# Create summary table if results exist
if (length(edu_gap_results) > 0) {
  edu_gap_summary <- data.frame(
    Education = names(edu_gap_results),
    GroupA_Count = sapply(edu_gap_results, function(x) round(x$group_a_count)),
    GroupB_Count = sapply(edu_gap_results, function(x) round(x$group_b_count)),
    GroupA_Mean = sapply(edu_gap_results, function(x) dollar(x$group_a_mean)),
    GroupB_Mean = sapply(edu_gap_results, function(x) dollar(x$group_b_mean)),
    Gap_Percent = sapply(edu_gap_results, function(x) paste0(x$gap_percent, "%")),
    Significant = sapply(edu_gap_results, function(x) 
      ifelse(x$significant, "Yes", "No")),
    stringsAsFactors = FALSE
  ) %>%
    mutate(Education = str_trunc(Education, 40))  # Truncate long education labels
  
  # Rename columns with actual group labels
  names(edu_gap_summary)[2:5] <- c(
    paste0(substr(GROUP_A_LABEL, 1, 10), "_N"),
    paste0(substr(GROUP_B_LABEL, 1, 10), "_N"),
    paste0(substr(GROUP_A_LABEL, 1, 10), "_Mean"),
    paste0(substr(GROUP_B_LABEL, 1, 10), "_Mean")
  )
  
  create_summary_table(edu_gap_summary, "Pay Gap Analysis by Education Level")
} else {
  cat("No education-specific results found with sufficient sample size.\n")
}
```

# Top Occupations Analysis

```{r top-occupations}
# Analyze top occupations for Group A
top_occupations <- group_a_data %>%
  as_survey_design(weights = PWGTP) %>%
  group_by(OCCP_label) %>%
  summarise(
    count = survey_total(),
    mean_earnings = survey_mean(PERNP, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(count >= MIN_OCCUPATION_COUNT) %>%
  arrange(desc(mean_earnings)) %>%
  slice_head(n = TOP_N_OCCUPATIONS)

# Format for display
top_occ_display <- top_occupations %>%
  mutate(
    Occupation = OCCP_label,
    `Sample Size` = round(count),
    `Mean Earnings` = dollar(mean_earnings)
  ) %>%
  select(Occupation, `Sample Size`, `Mean Earnings`)

create_summary_table(top_occ_display, 
                    paste("Top", TOP_N_OCCUPATIONS, "Occupations by Mean Earnings -", GROUP_A_LABEL))
```

# Visualization: Top Occupations

```{r top-occupations-plot}
#| fig-cap: "Top Occupations by Mean Earnings"

# Create bar plot
top_10_plot <- top_occupations %>%
  slice_head(n = 10) %>%
  mutate(OCCP_label = fct_reorder(OCCP_label, mean_earnings)) %>%
  ggplot(aes(x = mean_earnings, y = OCCP_label)) +
  geom_col(fill = "steelblue", alpha = 0.8) +
  scale_x_continuous(labels = dollar_format()) +
  labs(
    title = paste("Top 10 Occupations:", GROUP_A_LABEL),
    subtitle = paste(STATE_CODE, "- Ages", AGE_MIN, "to", AGE_MAX),
    x = "Mean Annual Earnings",
    y = NULL
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    axis.text.y = element_text(size = 10)
  )

print(top_10_plot)
```

# Occupation-Specific Pay Gap Analysis

```{r occupation-gaps}
# Test occupations from parameters
test_occupations <- OCCUPATION_GAP_ANALYSIS

occupation_results <- list()
for (occ in test_occupations) {
  result <- calculate_pay_gap(combined_data, occ)
  if (!is.null(result)) {
    occupation_results[[occ]] <- result
  }
}

# Create summary table if results exist
if (length(occupation_results) > 0) {
  occ_summary <- data.frame(
    Occupation = names(occupation_results),
    GroupA_Count = sapply(occupation_results, function(x) round(x$group_a_count)),
    GroupB_Count = sapply(occupation_results, function(x) round(x$group_b_count)),
    Gap_Percent = sapply(occupation_results, function(x) paste0(x$gap_percent, "%")),
    P_Value = sapply(occupation_results, function(x) 
      ifelse(is.na(x$p_value), "N/A", format(x$p_value, digits = 3))),
    Significant = sapply(occupation_results, function(x) 
      ifelse(x$significant, "Yes", "No")),
    stringsAsFactors = FALSE
  )
  
  # Rename columns with actual group labels
  names(occ_summary)[2:3] <- c(
    paste0(substr(GROUP_A_LABEL, 1, 15), "_N"),
    paste0(substr(GROUP_B_LABEL, 1, 15), "_N")
  )
  
  create_summary_table(occ_summary, "Pay Gap Analysis by Occupation")
} else {
  cat("No occupation-specific results found with sufficient sample size.\n")
}
```

# Custom Occupation Search

```{r occupation-search}
# Function to search for specific occupations
search_occupation <- function(search_term, data = group_a_data) {
  
  # First filter to check if any matches exist
  filtered_data <- data %>%
    filter(str_detect(OCCP_label, regex(search_term, ignore_case = TRUE)))
  
  # Return NULL if no matches found
  if (nrow(filtered_data) == 0) {
    return(NULL)
  }
  
  # Process matching data
  matching <- filtered_data %>%
    as_survey_design(weights = PWGTP) %>%
    group_by(OCCP_label) %>%
    summarise(
      count = survey_total(),
      mean_earnings = survey_mean(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    arrange(desc(mean_earnings))
  
  # Format and return results
  return(matching %>%
         mutate(
           Occupation = OCCP_label,
           `Sample Size` = round(count),
           `Mean Earnings` = dollar(mean_earnings)
         ) %>%
         select(Occupation, `Sample Size`, `Mean Earnings`))
}

# Example searches from parameters
example_searches <- OCCUPATION_SEARCH_EXAMPLES

cat("### Example Occupation Searches\n\n")
for (term in example_searches) {
  cat("**Searching for:", term, "**\n\n")
  results <- search_occupation(term)
  
  if (!is.null(results)) {
    print(knitr::kable(results, format = "pipe"))
    cat("\n")
  } else {
    cat("No results found.\n\n")
  }
}
```

# Summary Statistics

```{r summary-stats}
# Calculate summary statistics for both groups including education
summary_stats <- combined_data %>%
  as_survey_design(weights = PWGTP) %>%
  group_by(group) %>%
  summarise(
    n = survey_total(),
    mean_age = survey_mean(AGEP, na.rm = TRUE),
    mean_earnings = survey_mean(PERNP, na.rm = TRUE),
    median_earnings = survey_median(PERNP, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    Group = ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
    `Sample Size` = round(n),
    `Mean Age` = round(mean_age, 1),
    `Mean Earnings` = dollar(mean_earnings),
    `Median Earnings` = dollar(median_earnings)
  ) %>%
  select(Group, `Sample Size`, `Mean Age`, `Mean Earnings`, `Median Earnings`)

create_summary_table(summary_stats, "Summary Statistics by Group")

# Education level summary
edu_stats <- combined_data %>%
  group_by(group) %>%
  summarise(
    bachelor_plus = mean(SCHL >= "21", na.rm = TRUE) * 100,
    masters_plus = mean(SCHL >= "22", na.rm = TRUE) * 100,
    doctorate = mean(SCHL == "24", na.rm = TRUE) * 100,
    .groups = "drop"
  ) %>%
  mutate(
    Group = ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
    `Bachelor's or Higher (%)` = round(bachelor_plus, 1),
    `Master's or Higher (%)` = round(masters_plus, 1),
    `Doctorate (%)` = round(doctorate, 1)
  ) %>%
  select(Group, `Bachelor's or Higher (%)`, `Master's or Higher (%)`, `Doctorate (%)`)

create_summary_table(edu_stats, "Educational Attainment by Group")
```

# Methods

This analysis uses American Community Survey (ACS) 5-year Public Use Microdata Sample (PUMS) data from `r SURVEY_YEAR`. 

**Analysis Parameters:**
- Geographic Area: `r STATE_CODE`
- Age Range: `r AGE_MIN` to `r AGE_MAX`
- Group A: `r GROUP_A_LABEL`
  - Education Filter: `r ifelse(!is.null(GROUP_A_EDUCATION_CODE), paste("Code:", paste(GROUP_A_EDUCATION_CODE, collapse=",")), ifelse(!is.null(GROUP_A_EDUCATION_LABEL), paste("Label:", GROUP_A_EDUCATION_LABEL), "All education levels"))`
- Group B: `r GROUP_B_LABEL`
  - Education Filter: `r ifelse(!is.null(GROUP_B_EDUCATION_CODE), paste("Code:", paste(GROUP_B_EDUCATION_CODE, collapse=",")), ifelse(!is.null(GROUP_B_EDUCATION_LABEL), paste("Label:", GROUP_B_EDUCATION_LABEL), "All education levels"))`
- Minimum Education Level: `r ifelse(!is.null(MIN_EDUCATION_CODE), paste("Code", MIN_EDUCATION_CODE, "and above"), "None")`
- Minimum occupation sample size: `r MIN_OCCUPATION_COUNT`

**Statistical Methods:**
- All estimates use survey weights to account for complex sampling design
- Pay gaps calculated as: (Group B earnings - Group A earnings) / Group A earnings × 100
- Statistical significance tested using survey-weighted t-tests (α = 0.05)
- Mean earnings used as primary measure to capture full earnings distribution
- Educational attainment analyzed using SCHL variable from ACS PUMS

**Education Codes Reference:**
- 16: Regular high school diploma
- 18: Some college, but less than 1 year
- 21: Bachelor's degree
- 22: Master's degree
- 23: Professional degree beyond bachelor's
- 24: Doctorate degree

# Cache Information

```{r cache-info}
# Display cache files
cache_files <- list.files("cache_data", pattern = CACHE_PREFIX, full.names = TRUE)

if (length(cache_files) > 0) {
  cache_info <- file.info(cache_files)
  cache_summary <- data.frame(
    File = basename(cache_files),
    Size_MB = round(cache_info$size / 1024^2, 2),
    Modified = format(cache_info$mtime, "%Y-%m-%d %H:%M"),
    stringsAsFactors = FALSE
  )
  
  create_summary_table(cache_summary, "Cache Files")
  
  cat("\nTo refresh data: Set FORCE_REFRESH <- TRUE or delete cache files\n")
} else {
  cat("No cache files found for this analysis.\n")
}
```

---

*Report generated on `r format(Sys.Date(), "%B %d, %Y")` using R and Quarto*  
*Template Version: 2.0 - Enhanced with Educational Attainment*
