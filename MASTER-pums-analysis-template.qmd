---
title: "PUMS Pay Gap Analysis Template"
subtitle: "Enhanced Template with Educational Attainment Filtering and Debug Tracking"
description: "Using ACS5 database with education level parameters - Debug Version"
author: 
  - name: "Dan Swart, CPA (ret)"
    affiliations:
      - "SCUC-ISD Board of Trustees"
      - "Seat 6"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # Hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: true
    include-in-header: header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 14pt
    mainfont: "Cabin"
    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px



  # docx:
  #   highlight-style: github
  #   fig_caption: true



editor: source

quarto:
  render:
    cache-refresh: true


# for .qmd filesd
execute:
  echo: true
  message: false
  warning: false
  eval: true
  fig-width: 12
  fig-height: 10


# for .rmd files
knitr:
  opts_chunk:
    echo: true
    error: false
    warning: false
    message: false
    cache: false
    fig.width: 12
    fig.height: 10


---


```{r}
#| label: setup
#| include: false

# Prevent scientific notation globally
options(scipen = 999)

options(tigris_use_cache = TRUE)

# install.packages(c("mapview", "survey", "srvyr", "arcgislayers"))

# census_api_key("95496766c51541ee6f402c1e1a8658581285b759", install = TRUE, overwrite = TRUE)


# load libraries

library(tidyverse)
library(tidycensus)
library(dplyr)
library(survey)
library(srvyr)
library(stringr)
library(knitr)
library(DT)
library(ggplot2)
library(scales)
library(forcats)


# Force dplyr's select to take precedence
select <- dplyr::select
filter <- dplyr::filter

# Create cache directory
if (!dir.exists("cache_data")) {
  dir.create("cache_data")
}

# Set default chunk options
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 12,
  fig.height = 10
)

# Set global theme for consistent plots
theme_set(theme_minimal(base_size = 20) + 
          theme(
    plot.title = element_text(face = "bold", size = 26),    # adjust title size
    plot.subtitle = element_text(face = "bold", size = 24), # adjust subtitle size
    axis.title.x = element_text(face = "bold", size = 22),
    axis.title.y = element_text(face = "bold", size = 22),
    axis.text.x = element_text(face = "bold", size = 22, angle = 45, hjust = 1),
    legend.position = "bottom",
    strip.text = element_text(face = "bold"),
    panel.spacing.x = unit(1.5, "cm"),  # Horizontal spacing only
    panel.spacing.y = unit(1.5, "cm"),   # Vertical spacing only
    plot.margin = margin(20, 20, 20, 20, "pt")
    )
)


# Set seed for reproducibility
set.seed(123)

# Create debug tracking dataframe
debug_tracker <- data.frame(
  Step = character(),
  Description = character(),
  Sample_Size = numeric(),
  stringsAsFactors = FALSE
)

```


<!-- 
================================================================================
                        MODIFICATION INSTRUCTIONS
================================================================================

This template analyzes pay gaps between two demographic groups using PUMS data.
To adapt for your research, modify the ANALYSIS PARAMETERS section below.

STEP 1: DEFINE YOUR GROUPS
------------------------
- Group A and Group B can be any combination of sex, marital status, and education level
- Use tidycensus::pums_variables to find exact codes:
  > library(tidycensus)
  > View(pums_variables)
  > Search for SEX, MAR, SCHL, or other variables

Common codes:
- SEX: "1" = Male, "2" = Female  
- MAR: "1" = Married, "2" = Widowed, "3" = Divorced, "4" = Separated, "5" = Never married
- SCHL: Common education levels:
  * "16" = Regular high school diploma
  * "18" = Some college, but less than 1 year
  * "21" = Bachelor's degree
  * "22" = Master's degree
  * "23" = Professional degree beyond bachelor's
  * "24" = Doctorate degree

EDUCATIONAL ATTAINMENT FILTERING:
------------------------
You can filter by:
1. Specific education code: e.g., "23" for professional degree
2. Multiple codes: c("22", "23", "24") for graduate degrees
3. Education labels using regex: "Bachelor|Master" 
4. NULL to include all education levels

FINDING OCCUPATIONS:
------------------------
Occupations use partial text matching on OCCP_label field. To find occupations:
  > library(tidycensus)
  > pums_vars <- pums_variables
  > View(pums_vars %>% filter(var_code == "OCCP"))  # See all occupation labels
  
Example: "Manager" matches all manager types, "Nurse" matches all nursing occupations
For specific occupations, use more precise terms (e.g., "Registered nurses" vs "Nurse")

STEP 2: UPDATE PARAMETERS
------------------------
Edit the ANALYSIS PARAMETERS section below with your values

STEP 3: UPDATE REPORT TEXT
------------------------
Search and replace the group labels throughout the document

STEP 4: CLEAR CACHE (if changing data parameters)
------------------------
Delete the cache_data folder to force fresh data download

STEP 5: RENDER
------------------------
Click "Render" in RStudio or run: quarto render yourfile.qmd

================================================================================
-->

<!-- # Un-comment to look for PUMS education Codes -->

```{r pums-education-codes}

# # Load all variables available in PUMS
# View(tidycensus::pums_variables)
# 
# # View education codes specifically
# education_codes <- tidycensus::pums_variables %>%
#   filter(var_code == "SCHL", survey == "acs5", year == 2023) %>%
#   select(val_label)
# View(education_codes)

```


# ANALYSIS PARAMETERS {.unnumbered}

**Modify these parameters for your specific analysis:**

```{r parameters}
# ============================================
#           MAIN ANALYSIS PARAMETERS
# ============================================

# Geographic and time parameters
STATE_CODE <- "TX"           # State abbreviation
SURVEY_YEAR <- 2023          # Year of ACS data
AGE_MIN <- 40                # Minimum age
AGE_MAX <- 64                # Maximum age

# ============================================
#        EDUCATIONAL ATTAINMENT FILTERS
# ============================================
# Use NULL to include all education levels, or specify codes/labels

# Option 1: Filter by specific education code(s)
# Single code: "23" for professional degree
# Multiple codes: c("21", "22", "23", "24") for bachelor's and above
# NULL for all education levels

GROUP_A_EDUCATION_CODE <- 23  # NULL or a code like "23" for professional degree
GROUP_B_EDUCATION_CODE <- 23  # NULL or a code like c("21", "22") for bachelor's/master's

# Option 2: Filter by education label pattern (regex)
# Examples: "Bachelor", "Master|Professional", "degree"
# NULL to not filter by label

GROUP_A_EDUCATION_LABEL <- NULL  # Example: "Professional degree"
GROUP_B_EDUCATION_LABEL <- NULL  # Example: "Bachelor|Master"

# Minimum education level (optional)
# Filters to include only this code and higher
# Common thresholds: "16" (HS), "21" (Bachelor's), "22" (Master's)
MIN_EDUCATION_CODE <- NULL  # Example: "21" for bachelor's and above

# ============================================
#           GROUP DEFINITIONS
# ============================================

# Group A definition
GROUP_A_SEX <- "2"           # "1" = Male, "2" = Female
GROUP_A_MAR <- "5"           # "5" = Never married, NULL = all marital statuses
GROUP_A_LABEL <- "Never-Married Females"  # Display label for Group A

# Group B definition
GROUP_B_SEX <- "1"           # "1" = Male, "2" = Female  
GROUP_B_MAR <- "5"           # NULL = all marital statuses, or specify code
GROUP_B_LABEL <- "Never-Married Males" # Display label for Group B

# Analysis options
MIN_OCCUPATION_COUNT <- 30   # Minimum sample size for occupation analysis
TOP_N_OCCUPATIONS <- 20      # Number of top occupations to display

# Specify Occupations to analyze for pay gaps (partial text matching)
OCCUPATION_GAP_ANALYSIS <- c("MED-Physicians", "MED-Surgeons", "MED-Dentists", "MED-Pharmacists", 
                            "LGL-Lawyers, And Judges, Magistrates, And Other Judicial Workers", 
                            "EDU-Postsecondary Teachers", "MGR-General And Operations Managers", 
                            "EDU-Secondary School Teachers", "MED-Registered Nurses", 
                            "ENG-Engineer", "FIN-Accountants And Auditors", "MGR-Sales Managers")

# Additional occupations for detailed search examples
OCCUPATION_SEARCH_EXAMPLES <- c("Clerk", "Driver")

# Note: These use partial matching. "Manager" matches all manager occupations.
# For specific occupations, use precise terms like "General and operations managers"

# Cache management
CACHE_PREFIX <- "nm_fem_vs_nm_male_edu"  # Unique prefix for cache files
FORCE_REFRESH <- FALSE       # Set TRUE to ignore cache and download fresh data

# ============================================
#           DERIVED PARAMETERS
# ============================================

# Create unique cache paths based on parameters
cache_raw <- paste0("cache_data/", CACHE_PREFIX, "_raw.rds")
cache_processed <- paste0("cache_data/", CACHE_PREFIX, "_processed.rds")
cache_analysis <- paste0("cache_data/", CACHE_PREFIX, "_analysis.rds")

# Create analysis description with debugging
cat("\n=== BUILDING EDUCATION DESCRIPTIONS ===\n")

education_desc_a <- if (!is.null(GROUP_A_EDUCATION_CODE)) {
  desc <- paste0(" (Edu: ", paste(GROUP_A_EDUCATION_CODE, collapse = ","), ")")
  cat("Group A education description (from code):", desc, "\n")
  desc
} else if (!is.null(GROUP_A_EDUCATION_LABEL)) {
  desc <- paste0(" (Edu: ", GROUP_A_EDUCATION_LABEL, ")")
  cat("Group A education description (from label):", desc, "\n")
  desc
} else if (!is.null(MIN_EDUCATION_CODE)) {
  desc <- paste0(" (Edu >= ", MIN_EDUCATION_CODE, ")")
  cat("Group A education description (from min):", desc, "\n")
  desc
} else {
  cat("Group A education description: None (all education levels)\n")
  ""
}

education_desc_b <- if (!is.null(GROUP_B_EDUCATION_CODE)) {
  desc <- paste0(" (Edu: ", paste(GROUP_B_EDUCATION_CODE, collapse = ","), ")")
  cat("Group B education description (from code):", desc, "\n")
  desc
} else if (!is.null(GROUP_B_EDUCATION_LABEL)) {
  desc <- paste0(" (Edu: ", GROUP_B_EDUCATION_LABEL, ")")
  cat("Group B education description (from label):", desc, "\n")
  desc
} else if (!is.null(MIN_EDUCATION_CODE)) {
  desc <- paste0(" (Edu >= ", MIN_EDUCATION_CODE, ")")
  cat("Group B education description (from min):", desc, "\n")
  desc
} else {
  cat("Group B education description: None (all education levels)\n")
  ""
}

ANALYSIS_DESCRIPTION <- paste0(
  "Comparing ", GROUP_A_LABEL, education_desc_a, 
  " vs ", GROUP_B_LABEL, education_desc_b,
  " in ", STATE_CODE, " (Ages ", AGE_MIN, "-", AGE_MAX, ")"
)

cat("\n=== ANALYSIS CONFIGURATION ===\n")
cat("Description:", ANALYSIS_DESCRIPTION, "\n")
cat("Data Year:", SURVEY_YEAR, "\n")
cat("Cache Prefix:", CACHE_PREFIX, "\n")
cat("===============================\n\n")
```

# Data Functions

```{r functions}

# Enhanced function to filter PUMS data with comprehensive debugging
filter_pums_data <- function(data, sex_code, mar_code = NULL, 
                             edu_code = NULL, edu_label = NULL,
                             min_edu = MIN_EDUCATION_CODE,
                             age_min = AGE_MIN, age_max = AGE_MAX,
                             group_label = "Group") {
  
  cat("\n=== FILTERING", group_label, "===\n")
  cat("Starting sample size:", nrow(data), "\n")
  
  # Track unique values before filtering
  cat("\nUnique SEX values in data:", unique(data$SEX), "\n")
  cat("Filtering for SEX =", sex_code, "\n")
  
  result <- data %>%
    filter(SEX == sex_code)
  cat("After SEX filter:", nrow(result), "rows\n")
  
  result <- result %>%
    filter(AGEP >= age_min & AGEP <= age_max)
  cat("After AGE filter (", age_min, "-", age_max, "):", nrow(result), "rows\n")
  
  result <- result %>%
    filter(PERNP > 0)
  cat("After PERNP > 0 filter:", nrow(result), "rows\n")
  
  result <- result %>%
    filter(OCCP != "000N")
  cat("After OCCP != '000N' filter:", nrow(result), "rows\n")
  
  result <- result %>%
    filter(!is.na(OCCP))
  cat("After !is.na(OCCP) filter:", nrow(result), "rows\n")
  
  result <- result %>%
    filter(!is.na(PERNP))
  cat("After !is.na(PERNP) filter:", nrow(result), "rows\n")
  
  # Apply marital status filter if specified
  if (!is.null(mar_code)) {
    cat("\nUnique MAR values in current data:", unique(result$MAR), "\n")
    cat("Filtering for MAR =", mar_code, "\n")
    result <- result %>% filter(MAR == mar_code)
    cat("After MAR filter:", nrow(result), "rows\n")
  } else {
    cat("No MAR filter applied\n")
  }
  
  # Apply education code filter if specified
  if (!is.null(edu_code)) {
    cat("\nUnique SCHL values in current data:", length(unique(result$SCHL)), "unique values\n")
    cat("Sample of SCHL values:", head(unique(result$SCHL), 10), "\n")
    
    if (length(edu_code) == 1) {
      cat("Filtering for single SCHL code:", edu_code, "\n")
      # Check if any records match before filtering
      matches <- sum(result$SCHL == edu_code, na.rm = TRUE)
      cat("Records matching SCHL ==", edu_code, ":", matches, "\n")
      result <- result %>% filter(SCHL == edu_code)
    } else {
      cat("Filtering for multiple SCHL codes:", paste(edu_code, collapse = ", "), "\n")
      matches <- sum(result$SCHL %in% edu_code, na.rm = TRUE)
      cat("Records matching SCHL in specified codes:", matches, "\n")
      result <- result %>% filter(SCHL %in% edu_code)
    }
    cat("After SCHL code filter:", nrow(result), "rows\n")
  } else {
    cat("No SCHL code filter applied\n")
  }
  
  # Apply education label filter if specified
  if (!is.null(edu_label)) {
    cat("\nFiltering for SCHL_label pattern:", edu_label, "\n")
    if ("SCHL_label" %in% names(result)) {
      matches <- sum(str_detect(result$SCHL_label, regex(edu_label, ignore_case = TRUE)), na.rm = TRUE)
      cat("Records matching pattern:", matches, "\n")
      result <- result %>% 
        filter(str_detect(SCHL_label, regex(edu_label, ignore_case = TRUE)))
    } else {
      cat("WARNING: SCHL_label column not found in data\n")
    }
    cat("After SCHL label filter:", nrow(result), "rows\n")
  }
  
  # Apply minimum education filter if specified
  if (!is.null(min_edu)) {
    cat("\nFiltering for SCHL >=", min_edu, "\n")
    matches <- sum(result$SCHL >= min_edu, na.rm = TRUE)
    cat("Records with SCHL >=", min_edu, ":", matches, "\n")
    result <- result %>% filter(SCHL >= min_edu)
    cat("After minimum SCHL filter:", nrow(result), "rows\n")
  }
  
  cat("\nFINAL", group_label, "sample size:", nrow(result), "\n")
  cat("=============================\n")
  
  return(result)
}

# Function to calculate pay gap with statistical testing - WITH ERROR HANDLING
calculate_pay_gap <- function(data, occupation_filter = NULL) {
  
  # Apply occupation filter if specified
  if (!is.null(occupation_filter)) {
    data <- data %>%
      filter(str_detect(OCCP_label, regex(occupation_filter, ignore_case = TRUE)))
  }
  
  # Check for sufficient data
  if (nrow(data) < 10) return(NULL)
  
  # Check both groups are present
  groups <- unique(data$group)
  if (length(groups) < 2) return(NULL)
  
  # Try to use survey weights, fall back to unweighted if needed
  group_stats <- tryCatch({
    # Attempt survey-weighted analysis
    svy_data <- data %>% as_survey_design(weights = PWGTP)
    
    svy_data %>%
      group_by(group) %>%
      summarise(
        count = survey_total(),
        mean_earnings = survey_mean(PERNP, na.rm = TRUE),
        median_earnings = survey_median(PERNP, na.rm = TRUE),
        .groups = "drop"
      )
  }, error = function(e) {
    # Fall back to unweighted analysis
    data %>%
      group_by(group) %>%
      summarise(
        count = n(),
        mean_earnings = mean(PERNP, na.rm = TRUE),
        median_earnings = median(PERNP, na.rm = TRUE),
        .groups = "drop"
      )
  })
  
  # Calculate gap (Group B - Group A)
  group_a_stats <- filter(group_stats, group == "Group_A")
  group_b_stats <- filter(group_stats, group == "Group_B")
  
  if (nrow(group_a_stats) == 0 || nrow(group_b_stats) == 0) return(NULL)
  
  gap_dollars <- group_b_stats$mean_earnings - group_a_stats$mean_earnings
  gap_percent <- (gap_dollars / group_a_stats$mean_earnings) * 100
  
  # Statistical test - try survey test first, then regular t-test
  p_value <- tryCatch({
    svy_data <- data %>% as_survey_design(weights = PWGTP)
    test <- svyttest(PERNP ~ group, svy_data)
    test$p.value
  }, error = function(e) {
    # Try regular t-test as fallback
    tryCatch({
      test <- t.test(PERNP ~ group, data = data)
      test$p.value
    }, error = function(e2) NA)
  })
  
  return(list(
    occupation = ifelse(is.null(occupation_filter), "All Occupations", occupation_filter),
    group_a_mean = group_a_stats$mean_earnings,
    group_b_mean = group_b_stats$mean_earnings,
    gap_dollars = gap_dollars,
    gap_percent = round(gap_percent, 1),
    p_value = p_value,
    significant = !is.na(p_value) && p_value < 0.05,
    group_a_count = group_a_stats$count,
    group_b_count = group_b_stats$count
  ))
}

# Function to create formatted tables
create_summary_table <- function(data, title = NULL) {
  if (knitr::is_html_output()) {
    datatable(data, caption = title, options = list(pageLength = 10))
  } else {
    knitr::kable(data, caption = title, format = "simple")
  }
}

# Helper function to explore available occupations in the data
explore_occupations <- function(search_term = NULL, data = pums_data) {
  # Get unique occupations with counts
  occ_summary <- data %>%
    filter(!is.na(OCCP_label), OCCP != "000N") %>%
    group_by(OCCP, OCCP_label) %>%
    summarise(count = n(), .groups = "drop") %>%
    arrange(desc(count))
  
  # Filter if search term provided
  if (!is.null(search_term)) {
    occ_summary <- occ_summary %>%
      filter(str_detect(OCCP_label, regex(search_term, ignore_case = TRUE)))
  }
  
  return(occ_summary)
}

# New function to explore education levels in the data
explore_education <- function(data = pums_data) {
  edu_summary <- data %>%
    filter(!is.na(SCHL_label)) %>%
    group_by(SCHL, SCHL_label) %>%
    summarise(
      count = n(),
      mean_earnings = mean(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    arrange(SCHL)
  
  return(edu_summary)
}

# Function to search for specific occupations - WITH ERROR HANDLING
search_occupation <- function(search_term, data = group_a_data) {
  
  # First filter to check if any matches exist
  filtered_data <- data %>%
    filter(str_detect(OCCP_label, regex(search_term, ignore_case = TRUE)))
  
  # Return NULL if no matches found or insufficient data
  if (nrow(filtered_data) < 5) {
    return(NULL)
  }
  
  # Try to process with survey weights, fall back to simple means if survey fails
  matching <- tryCatch({
    # Attempt survey-weighted analysis
    filtered_data %>%
      as_survey_design(weights = PWGTP) %>%
      group_by(OCCP_label) %>%
      summarise(
        count = survey_total(),
        mean_earnings = survey_mean(PERNP, na.rm = TRUE),
        .groups = "drop"
      ) %>%
      arrange(desc(mean_earnings))
  }, error = function(e) {
    # Fall back to unweighted analysis if survey design fails
    filtered_data %>%
      group_by(OCCP_label) %>%
      summarise(
        count = n(),
        mean_earnings = mean(PERNP, na.rm = TRUE),
        .groups = "drop"
      ) %>%
      arrange(desc(mean_earnings))
  })
  
  # Format and return results
  return(matching %>%
         mutate(
           Occupation = OCCP_label,
           `Sample Size` = round(count),
           `Mean Earnings` = dollar(mean_earnings)
         ) %>%
         select(Occupation, `Sample Size`, `Mean Earnings`))
}
```

# Data Collection

```{r data-collection}
#| cache: true

cat("\n### DATA COLLECTION PHASE ###\n")

# Check cache or download fresh data
if (!FORCE_REFRESH && file.exists(cache_raw)) {
  cat("Loading cached data from:", cache_raw, "\n")
  pums_data <- readRDS(cache_raw)
  cat("Cached data loaded successfully\n")
} else {
  cat("Downloading PUMS data from Census API...\n")
  cat("State:", STATE_CODE, "\n")
  cat("Year:", SURVEY_YEAR, "\n")
  cat("This may take several minutes...\n\n")
  
  # Download all PUMS data
  invisible(capture.output(
    pums_data <- get_pums(
      variables = c("SEX", "MAR", "SCHL", "OCCP", "PINCP", "PERNP", "AGEP", "COW"),
      state = STATE_CODE,
      survey = "acs5",
      year = SURVEY_YEAR,
      recode = TRUE
    )
  ))
  
  # Save to cache
  saveRDS(pums_data, cache_raw)
  cat("Data downloaded and saved to cache:", cache_raw, "\n")
}

cat("\n=== RAW DATA SUMMARY ===\n")
cat("Total records downloaded:", nrow(pums_data), "\n")
cat("Variables included:", paste(names(pums_data), collapse = ", "), "\n")

# Check SCHL values
cat("\n=== EDUCATION (SCHL) VALUES CHECK ===\n")
schl_summary <- pums_data %>%
  filter(!is.na(SCHL)) %>%
  group_by(SCHL) %>%
  summarise(count = n()) %>%
  arrange(desc(count))

cat("Total unique SCHL codes:", nrow(schl_summary), "\n")
cat("Top 10 SCHL codes by frequency:\n")
print(head(schl_summary, 10))

# Check if code 23 exists
if (23 %in% schl_summary$SCHL) {
  cat("\nSCHL code 23 found:", schl_summary$count[schl_summary$SCHL == 23], "records\n")
} else if ("23" %in% schl_summary$SCHL) {
  cat("\nSCHL code '23' (character) found:", schl_summary$count[schl_summary$SCHL == "23"], "records\n")
} else {
  cat("\nWARNING: SCHL code 23 NOT found in data!\n")
}

cat("================================\n")
```

# Data Processing

```{r data-processing}
#| cache: true

cat("\n### DATA PROCESSING PHASE ###\n")

# Check cache or process data
if (!FORCE_REFRESH && file.exists(cache_processed)) {
  cat("Loading cached processed data from:", cache_processed, "\n")
  processed_data <- readRDS(cache_processed)
  group_a_data <- processed_data$group_a
  group_b_data <- processed_data$group_b
  combined_data <- processed_data$combined
  cat("Cached processed data loaded successfully\n")
  cat("Group A size from cache:", nrow(group_a_data), "\n")
  cat("Group B size from cache:", nrow(group_b_data), "\n")
} else {
  cat("Processing data with filters...\n\n")
  
  # Check data types before filtering
  cat("=== DATA TYPE CHECK ===\n")
  cat("SCHL data type:", class(pums_data$SCHL), "\n")
  cat("GROUP_A_EDUCATION_CODE type:", class(GROUP_A_EDUCATION_CODE), "\n")
  cat("GROUP_B_EDUCATION_CODE type:", class(GROUP_B_EDUCATION_CODE), "\n")
  
  # Convert education codes to match data type if needed
  if (is.numeric(pums_data$SCHL[1]) && is.numeric(GROUP_A_EDUCATION_CODE)) {
    cat("Both SCHL and education codes are numeric - good!\n")
  } else if (is.character(pums_data$SCHL[1]) && is.numeric(GROUP_A_EDUCATION_CODE)) {
    cat("Converting numeric education codes to character to match SCHL\n")
    GROUP_A_EDUCATION_CODE <- as.character(GROUP_A_EDUCATION_CODE)
    GROUP_B_EDUCATION_CODE <- as.character(GROUP_B_EDUCATION_CODE)
  } else if (is.numeric(pums_data$SCHL[1]) && is.character(GROUP_A_EDUCATION_CODE)) {
    cat("Converting character education codes to numeric to match SCHL\n")
    GROUP_A_EDUCATION_CODE <- as.numeric(GROUP_A_EDUCATION_CODE)
    GROUP_B_EDUCATION_CODE <- as.numeric(GROUP_B_EDUCATION_CODE)
  }
  
  # Filter Group A with education parameters
  group_a_data <- filter_pums_data(
    pums_data, 
    GROUP_A_SEX, 
    GROUP_A_MAR,
    edu_code = GROUP_A_EDUCATION_CODE,
    edu_label = GROUP_A_EDUCATION_LABEL,
    group_label = paste("Group A -", GROUP_A_LABEL)
  )
  
  # Filter Group B with education parameters
  group_b_data <- filter_pums_data(
    pums_data, 
    GROUP_B_SEX, 
    GROUP_B_MAR,
    edu_code = GROUP_B_EDUCATION_CODE,
    edu_label = GROUP_B_EDUCATION_LABEL,
    group_label = paste("Group B -", GROUP_B_LABEL)
  )
  
  # Combine with group labels
  combined_data <- bind_rows(
    group_a_data %>% mutate(group = "Group_A"),
    group_b_data %>% mutate(group = "Group_B")
  )
  
  cat("\n=== FINAL PROCESSING SUMMARY ===\n")
  cat("Group A (", GROUP_A_LABEL, "):", nrow(group_a_data), "records\n")
  cat("Group B (", GROUP_B_LABEL, "):", nrow(group_b_data), "records\n")
  cat("Combined data:", nrow(combined_data), "records\n")
  
  # Save processed data
  processed_data <- list(
    group_a = group_a_data,
    group_b = group_b_data,
    combined = combined_data
  )
  saveRDS(processed_data, cache_processed)
  cat("\nData processed and saved to cache:", cache_processed, "\n")
}

# Display sample summary
sample_summary <- data.frame(
  Group = c(GROUP_A_LABEL, GROUP_B_LABEL),
  `Sample Size` = c(nrow(group_a_data), nrow(group_b_data)),
  `Age Range` = paste0(AGE_MIN, "-", AGE_MAX),
  stringsAsFactors = FALSE
)

cat("\n### SAMPLE COMPOSITION TABLE ###\n")
create_summary_table(sample_summary, "Sample Composition")

# Additional debugging: Check education distribution in final groups
cat("\n=== EDUCATION DISTRIBUTION IN FINAL GROUPS ===\n")
if (nrow(group_a_data) > 0) {
  cat("\nGroup A education codes:\n")
  edu_dist_a <- table(group_a_data$SCHL)
  print(head(sort(edu_dist_a, decreasing = TRUE), 10))
}

if (nrow(group_b_data) > 0) {
  cat("\nGroup B education codes:\n")
  edu_dist_b <- table(group_b_data$SCHL)
  print(head(sort(edu_dist_b, decreasing = TRUE), 10))
}

cat("================================\n")
```

# Educational Attainment Distribution

```{r education-distribution}
cat("\n### EDUCATIONAL ATTAINMENT ANALYSIS ###\n")

# Analyze education distribution for both groups
edu_distribution <- combined_data %>%
  group_by(group, SCHL_label) %>%
  summarise(count = n(), .groups = "drop") %>%
  mutate(
    Group = ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
    Education = SCHL_label,
    Count = count
  ) %>%
  select(Group, Education, Count) %>%
  arrange(Group, desc(Count))

cat("Total unique education levels found:", length(unique(edu_distribution$Education)), "\n")

# Display top education levels for each group
edu_top10 <- edu_distribution %>%
  group_by(Group) %>%
  slice_head(n = 10) %>%
  ungroup()

create_summary_table(edu_top10, "Top 10 Education Levels by Group")

# Debug: Show education distribution for filtered code
if (!is.null(GROUP_A_EDUCATION_CODE)) {
  cat("\nFiltered education for Group A (code", GROUP_A_EDUCATION_CODE, "):\n")
  filtered_edu_a <- edu_distribution %>%
    filter(Group == GROUP_A_LABEL)
  if (nrow(filtered_edu_a) > 0) {
    print(filtered_edu_a)
  } else {
    cat("No records found with specified education filter\n")
  }
}

if (!is.null(GROUP_B_EDUCATION_CODE)) {
  cat("\nFiltered education for Group B (code", GROUP_B_EDUCATION_CODE, "):\n")
  filtered_edu_b <- edu_distribution %>%
    filter(Group == GROUP_B_LABEL)
  if (nrow(filtered_edu_b) > 0) {
    print(filtered_edu_b)
  } else {
    cat("No records found with specified education filter\n")
  }
}

cat("================================\n")
```

# Explore Available Occupations (Optional)

```{r explore-occupations}
#| eval: false
# OPTIONAL: Run this chunk to explore occupations in your data
# Set eval: true above to include in report

# See top 20 most common occupations in the data
common_occupations <- explore_occupations(data = pums_data) %>%
  slice_head(n = 20) %>%
  mutate(OCCP_label = str_trunc(OCCP_label, 60))  # Truncate long names

cat("### Most Common Occupations in Dataset\n")
print(knitr::kable(common_occupations, format = "pipe"))

# Search for specific occupation terms
cat("\n### Search Example: All 'Manager' Occupations\n")
manager_occs <- explore_occupations("Manager", data = pums_data) %>%
  slice_head(n = 10)
print(knitr::kable(manager_occs, format = "pipe"))

# Search for healthcare occupations
cat("\n### Search Example: Healthcare Occupations\n")
health_occs <- explore_occupations("nurse|physician|doctor|medical", data = pums_data) %>%
  slice_head(n = 10)
print(knitr::kable(health_occs, format = "pipe"))
```

# Overall Pay Gap Analysis

```{r overall-analysis}
cat("\n### OVERALL PAY GAP ANALYSIS ###\n")
cat("Combined data size for analysis:", nrow(combined_data), "\n")

# Calculate overall pay gap
overall_gap <- calculate_pay_gap(combined_data)

if (!is.null(overall_gap)) {
  cat("Pay gap calculation successful\n")
  cat("Group A mean:", dollar(overall_gap$group_a_mean), "\n")
  cat("Group B mean:", dollar(overall_gap$group_b_mean), "\n")
  cat("Gap:", overall_gap$gap_percent, "%\n")
  
  # Create summary table
  overall_summary <- data.frame(
    Metric = c(
      paste(GROUP_A_LABEL, "Mean Earnings"),
      paste(GROUP_B_LABEL, "Mean Earnings"),
      "Pay Gap ($)",
      "Pay Gap (%)",
      "P-value",
      "Statistically Significant"
    ),
    Value = c(
      dollar(overall_gap$group_a_mean),
      dollar(overall_gap$group_b_mean),
      dollar(overall_gap$gap_dollars),
      paste0(overall_gap$gap_percent, "%"),
      format(overall_gap$p_value, scientific = TRUE, digits = 3),
      ifelse(overall_gap$significant, "Yes", "No")
    ),
    stringsAsFactors = FALSE
  )
  
  create_summary_table(overall_summary, "Overall Pay Gap Analysis")
} else {
  cat("WARNING: Insufficient data for overall analysis\n")
  cat("Check that both groups have sufficient sample sizes\n")
}

cat("================================\n")
```

# Pay Gap by Education Level

```{r education-gap-analysis}
cat("\n### PAY GAP BY EDUCATION LEVEL ###\n")

# Analyze pay gaps by education level
edu_levels <- combined_data %>%
  group_by(SCHL_label) %>%
  summarise(total_count = n(), .groups = "drop") %>%
  filter(total_count >= MIN_OCCUPATION_COUNT) %>%
  pull(SCHL_label)

cat("Education levels with sufficient sample size (>=", MIN_OCCUPATION_COUNT, "):", length(edu_levels), "\n")

edu_gap_results <- list()
for (edu in edu_levels) {
  edu_data <- combined_data %>%
    filter(SCHL_label == edu)
  
  # Skip if insufficient data
  if (nrow(edu_data) < 10) {
    cat("Skipping", edu, "- insufficient data (<10 records)\n")
    next
  }
  
  result <- calculate_pay_gap(edu_data)
  if (!is.null(result)) {
    edu_gap_results[[edu]] <- result
    cat("Analyzed:", edu, "\n")
  }
}

# Create summary table if results exist
if (length(edu_gap_results) > 0) {
  cat("\nSuccessfully analyzed", length(edu_gap_results), "education levels\n")
  
  edu_gap_summary <- data.frame(
    Education = names(edu_gap_results),
    GroupA_Count = sapply(edu_gap_results, function(x) round(x$group_a_count)),
    GroupB_Count = sapply(edu_gap_results, function(x) round(x$group_b_count)),
    GroupA_Mean = sapply(edu_gap_results, function(x) dollar(x$group_a_mean)),
    GroupB_Mean = sapply(edu_gap_results, function(x) dollar(x$group_b_mean)),
    Gap_Percent = sapply(edu_gap_results, function(x) paste0(x$gap_percent, "%")),
    Significant = sapply(edu_gap_results, function(x) 
      ifelse(x$significant, "Yes", "No")),
    stringsAsFactors = FALSE
  ) %>%
    mutate(Education = str_trunc(Education, 40))  # Truncate long education labels
  
  # Rename columns with actual group labels
  names(edu_gap_summary)[2:5] <- c(
    paste0(substr(GROUP_A_LABEL, 1, 10), "_N"),
    paste0(substr(GROUP_B_LABEL, 1, 10), "_N"),
    paste0(substr(GROUP_A_LABEL, 1, 10), "_Mean"),
    paste0(substr(GROUP_B_LABEL, 1, 10), "_Mean")
  )
  
  create_summary_table(edu_gap_summary, "Pay Gap Analysis by Education Level")
} else {
  cat("WARNING: No education-specific results found with sufficient sample size\n")
}

cat("================================\n")
```

# Top Occupations Analysis

```{r top-occupations}
cat("\n### TOP OCCUPATIONS ANALYSIS ###\n")
cat("Analyzing top occupations for Group A\n")
cat("Group A sample size:", nrow(group_a_data), "\n")

# Analyze top occupations for Group A - WITH ERROR HANDLING
top_occupations <- tryCatch({
  cat("Attempting survey-weighted analysis...\n")
  # Try survey-weighted analysis
  result <- group_a_data %>%
    as_survey_design(weights = PWGTP) %>%
    group_by(OCCP_label) %>%
    summarise(
      count = survey_total(),
      mean_earnings = survey_mean(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    filter(count >= MIN_OCCUPATION_COUNT) %>%
    arrange(desc(mean_earnings)) %>%
    slice_head(n = TOP_N_OCCUPATIONS)
  cat("Survey-weighted analysis successful\n")
  result
}, error = function(e) {
  cat("Survey-weighted analysis failed, using unweighted analysis\n")
  cat("Error:", e$message, "\n")
  # Fall back to unweighted analysis
  group_a_data %>%
    group_by(OCCP_label) %>%
    summarise(
      count = n(),
      mean_earnings = mean(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    filter(count >= MIN_OCCUPATION_COUNT) %>%
    arrange(desc(mean_earnings)) %>%
    slice_head(n = TOP_N_OCCUPATIONS)
})

# Format for display
if (nrow(top_occupations) > 0) {
  cat("Found", nrow(top_occupations), "occupations with sufficient sample size\n")
  
  top_occ_display <- top_occupations %>%
    mutate(
      Occupation = OCCP_label,
      `Sample Size` = round(count),
      `Mean Earnings` = dollar(mean_earnings)
    ) %>%
    select(Occupation, `Sample Size`, `Mean Earnings`)
  
  create_summary_table(top_occ_display, 
                      paste("Top", TOP_N_OCCUPATIONS, "Occupations by Mean Earnings -", GROUP_A_LABEL))
} else {
  cat("WARNING: Insufficient data for top occupations analysis\n")
}

cat("================================\n")
```

# Visualization: Top Occupations

```{r top-occupations-plot}
#| fig-cap: "Top Occupations by Mean Earnings"

cat("\n### TOP OCCUPATIONS VISUALIZATION ###\n")

# Create bar plot only if we have data
if (exists("top_occupations") && nrow(top_occupations) > 0) {
  cat("Creating visualization with", min(10, nrow(top_occupations)), "occupations\n")
  
  top_10_plot <- top_occupations %>%
    slice_head(n = 10) %>%
    mutate(OCCP_label = fct_reorder(OCCP_label, mean_earnings)) %>%
    ggplot(aes(x = mean_earnings, y = OCCP_label)) +
    geom_col(fill = "steelblue", alpha = 0.8) +
    scale_x_continuous(labels = dollar_format()) +
    labs(
      title = paste("Top 10 Occupations:", GROUP_A_LABEL),
      subtitle = paste(STATE_CODE, "- Ages", AGE_MIN, "to", AGE_MAX),
      x = "Mean Annual Earnings",
      y = NULL
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.text.y = element_text(size = 10)
    )
  
  print(top_10_plot)
} else {
  cat("WARNING: Insufficient data for visualization\n")
}

cat("================================\n")
```

# Occupation-Specific Pay Gap Analysis

```{r occupation-gaps}
cat("\n### OCCUPATION-SPECIFIC PAY GAP ANALYSIS ###\n")

# Test occupations from parameters
test_occupations <- OCCUPATION_GAP_ANALYSIS
cat("Testing", length(test_occupations), "occupation categories\n")

occupation_results <- list()
for (occ in test_occupations) {
  cat("Analyzing:", occ, "... ")
  result <- calculate_pay_gap(combined_data, occ)
  if (!is.null(result)) {
    occupation_results[[occ]] <- result
    cat("Success (n=", round(result$group_a_count + result$group_b_count), ")\n")
  } else {
    cat("Insufficient data\n")
  }
}

# Create summary table if results exist
if (length(occupation_results) > 0) {
  cat("\nSuccessfully analyzed", length(occupation_results), "occupations\n")
  
  occ_summary <- data.frame(
    Occupation = names(occupation_results),
    GroupA_Count = sapply(occupation_results, function(x) round(x$group_a_count)),
    GroupB_Count = sapply(occupation_results, function(x) round(x$group_b_count)),
    Gap_Percent = sapply(occupation_results, function(x) paste0(x$gap_percent, "%")),
    P_Value = sapply(occupation_results, function(x) 
      ifelse(is.na(x$p_value), "N/A", format(x$p_value, digits = 3))),
    Significant = sapply(occupation_results, function(x) 
      ifelse(x$significant, "Yes", "No")),
    stringsAsFactors = FALSE
  )
  
  # Rename columns with actual group labels
  names(occ_summary)[2:3] <- c(
    paste0(substr(GROUP_A_LABEL, 1, 15), "_N"),
    paste0(substr(GROUP_B_LABEL, 1, 15), "_N")
  )
  
  create_summary_table(occ_summary, "Pay Gap Analysis by Occupation")
} else {
  cat("WARNING: No occupation-specific results found with sufficient sample size\n")
}

cat("================================\n")
```

# Custom Occupation Search

```{r occupation-search}
cat("\n### CUSTOM OCCUPATION SEARCH ###\n")

# Example searches from parameters
example_searches <- OCCUPATION_SEARCH_EXAMPLES

cat("Performing", length(example_searches), "example searches\n\n")

for (term in example_searches) {
  cat("**Searching for:", term, "**\n")
  results <- search_occupation(term)
  
  if (!is.null(results)) {
    cat("Found", nrow(results), "matching occupations\n")
    print(knitr::kable(results, format = "pipe"))
    cat("\n")
  } else {
    cat("No results found (insufficient data)\n\n")
  }
}

cat("================================\n")
```

# Summary Statistics

```{r summary-stats}
cat("\n### SUMMARY STATISTICS ###\n")

# Calculate summary statistics for both groups including education - WITH ERROR HANDLING
summary_stats <- tryCatch({
  cat("Attempting survey-weighted summary statistics...\n")
  # Try survey-weighted analysis
  result <- combined_data %>%
    as_survey_design(weights = PWGTP) %>%
    group_by(group) %>%
    summarise(
      n = survey_total(),
      mean_age = survey_mean(AGEP, na.rm = TRUE),
      mean_earnings = survey_mean(PERNP, na.rm = TRUE),
      median_earnings = survey_median(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(
      Group = ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
      `Sample Size` = round(n),
      `Mean Age` = round(mean_age, 1),
      `Mean Earnings` = dollar(mean_earnings),
      `Median Earnings` = dollar(median_earnings)
    ) %>%
    select(Group, `Sample Size`, `Mean Age`, `Mean Earnings`, `Median Earnings`)
  cat("Survey-weighted statistics calculated successfully\n")
  result
}, error = function(e) {
  cat("Survey-weighted analysis failed, using unweighted statistics\n")
  cat("Error:", e$message, "\n")
  # Fall back to unweighted analysis
  combined_data %>%
    group_by(group) %>%
    summarise(
      n = n(),
      mean_age = mean(AGEP, na.rm = TRUE),
      mean_earnings = mean(PERNP, na.rm = TRUE),
      median_earnings = median(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    mutate(
      Group = ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
      `Sample Size` = n,
      `Mean Age` = round(mean_age, 1),
      `Mean Earnings` = dollar(mean_earnings),
      `Median Earnings` = dollar(median_earnings)
    ) %>%
    select(Group, `Sample Size`, `Mean Age`, `Mean Earnings`, `Median Earnings`)
})

create_summary_table(summary_stats, "Summary Statistics by Group")

# Education level summary
cat("\nCalculating education level percentages...\n")
edu_stats <- combined_data %>%
  group_by(group) %>%
  summarise(
    bachelor_plus = mean(SCHL >= "21", na.rm = TRUE) * 100,
    masters_plus = mean(SCHL >= "22", na.rm = TRUE) * 100,
    doctorate = mean(SCHL == "24", na.rm = TRUE) * 100,
    .groups = "drop"
  ) %>%
  mutate(
    Group = ifelse(group == "Group_A", GROUP_A_LABEL, GROUP_B_LABEL),
    `Bachelor's or Higher (%)` = round(bachelor_plus, 1),
    `Master's or Higher (%)` = round(masters_plus, 1),
    `Doctorate (%)` = round(doctorate, 1)
  ) %>%
  select(Group, `Bachelor's or Higher (%)`, `Master's or Higher (%)`, `Doctorate (%)`)

create_summary_table(edu_stats, "Educational Attainment by Group")

cat("================================\n")
```

# Debug Summary

```{r debug-summary}
cat("\n### FINAL DEBUG SUMMARY ###\n")
cat("=====================================\n")

# Create final summary
debug_summary <- data.frame(
  Stage = c(
    "Raw Data Downloaded",
    "After Basic Filters (Group A)",
    "After Education Filter (Group A)",
    "After Basic Filters (Group B)",
    "After Education Filter (Group B)",
    "Combined Dataset"
  ),
  Sample_Size = c(
    nrow(pums_data),
    NA,  # Would need to track this separately
    nrow(group_a_data),
    NA,  # Would need to track this separately
    nrow(group_b_data),
    nrow(combined_data)
  ),
  stringsAsFactors = FALSE
)

# Display parameters used
cat("PARAMETERS USED:\n")
cat("- State:", STATE_CODE, "\n")
cat("- Year:", SURVEY_YEAR, "\n")
cat("- Age Range:", AGE_MIN, "-", AGE_MAX, "\n")
cat("- Group A Sex:", GROUP_A_SEX, "| Mar:", GROUP_A_MAR, "| Edu:", GROUP_A_EDUCATION_CODE, "\n")
cat("- Group B Sex:", GROUP_B_SEX, "| Mar:", GROUP_B_MAR, "| Edu:", GROUP_B_EDUCATION_CODE, "\n")
cat("\nFINAL SAMPLE SIZES:\n")
cat("- Group A:", nrow(group_a_data), "\n")
cat("- Group B:", nrow(group_b_data), "\n")
cat("- Combined:", nrow(combined_data), "\n")

if (nrow(group_a_data) == 0 || nrow(group_b_data) == 0) {
  cat("\n⚠️ WARNING: One or both groups have zero records!\n")
  cat("Check that:\n")
  cat("1. Education code exists in the data\n")
  cat("2. Data types match (numeric vs character)\n")
  cat("3. Combination of filters doesn't exclude all records\n")
}

cat("=====================================\n")
```

# Methods

This analysis uses American Community Survey (ACS) 5-year Public Use Microdata Sample (PUMS) data from `r SURVEY_YEAR`. 

**Analysis Parameters:**
- Geographic Area: `r STATE_CODE`
- Age Range: `r AGE_MIN` to `r AGE_MAX`
- Group A: `r GROUP_A_LABEL`
  - Education Filter: `r ifelse(!is.null(GROUP_A_EDUCATION_CODE), paste("Code:", paste(GROUP_A_EDUCATION_CODE, collapse=",")), ifelse(!is.null(GROUP_A_EDUCATION_LABEL), paste("Label:", GROUP_A_EDUCATION_LABEL), "All education levels"))`
- Group B: `r GROUP_B_LABEL`
  - Education Filter: `r ifelse(!is.null(GROUP_B_EDUCATION_CODE), paste("Code:", paste(GROUP_B_EDUCATION_CODE, collapse=",")), ifelse(!is.null(GROUP_B_EDUCATION_LABEL), paste("Label:", GROUP_B_EDUCATION_LABEL), "All education levels"))`
- Minimum Education Level: `r ifelse(!is.null(MIN_EDUCATION_CODE), paste("Code", MIN_EDUCATION_CODE, "and above"), "None")`
- Minimum occupation sample size: `r MIN_OCCUPATION_COUNT`

**Statistical Methods:**
- All estimates use survey weights to account for complex sampling design
- Pay gaps calculated as: (Group B earnings - Group A earnings) / Group A earnings × 100
- Statistical significance tested using survey-weighted t-tests (α = 0.05)
- Mean earnings used as primary measure to capture full earnings distribution
- Educational attainment analyzed using SCHL variable from ACS PUMS
- **Note:** When sample sizes are too small for survey-weighted analysis, the template automatically falls back to unweighted statistics to prevent errors

**Education Codes Reference:**
- 16: Regular high school diploma
- 18: Some college, but less than 1 year
- 21: Bachelor's degree
- 22: Master's degree
- 23: Professional degree beyond bachelor's
- 24: Doctorate degree

# Cache Information

```{r cache-info}
cat("\n### CACHE INFORMATION ###\n")

# Display cache files
cache_files <- list.files("cache_data", pattern = CACHE_PREFIX, full.names = TRUE)

if (length(cache_files) > 0) {
  cat("Found", length(cache_files), "cache files\n")
  
  cache_info <- file.info(cache_files)
  cache_summary <- data.frame(
    File = basename(cache_files),
    Size_MB = round(cache_info$size / 1024^2, 2),
    Modified = format(cache_info$mtime, "%Y-%m-%d %H:%M"),
    stringsAsFactors = FALSE
  )
  
  create_summary_table(cache_summary, "Cache Files")
  
  cat("\nTo refresh data: Set FORCE_REFRESH <- TRUE or delete cache files\n")
} else {
  cat("No cache files found for this analysis\n")
  cat("Data will be downloaded fresh on next run\n")
}

cat("================================\n")

```

---

*Report generated on `r format(Sys.Date(), "%B %d, %Y")` using R and Quarto*  
*Template Version: 2.2 - Enhanced with Comprehensive Debugging*


