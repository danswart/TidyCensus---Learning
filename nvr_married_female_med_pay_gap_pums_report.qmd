---
title: "Texas Pay Gap Analysis: Never-Married Females vs Males"
subtitle: "By Selected Occupation"
description: ""
author: 
  - name: "Dan Swart, CPA (ret)"
    affiliations:
      - "SCUC-ISD Board of Trustees"
      - "Seat 6"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # True = hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    # embed-resources: true
    include-in-header: header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 14pt
    # mainfont: "Cabin"
    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px
  # docx:
  #   highlight-style: github
  #   fig_caption: true
editor: source
# for .qmd filesd
execute:
  echo: true
  message: false
  warning: false
  eval: true
  fig-width: 12
  fig-height: 10
# for .rmd files
knitr:
  opts_chunk:
    echo: true
    error: false
    warning: false
    message: false
    eval: true
    cache: false
---

# Executive Summary

This report analyzes **mean (average) earnings** differences between never-married females and males in Texas using American Community Survey Public Use Microdata Sample (PUMS) data. The analysis focuses on working-age adults (25-64) with positive earnings, examining both overall patterns and occupation-specific disparities.

**Key Focus:** All analysis uses **mean income** rather than median to capture the full earning potential and account for high earners in each occupation.


***Run > library(tidycensus) and View(pums_variables) in the console at anytime to query the entire PUMS variables dataframe)***


```{r setup}
#| include: false
library(tidycensus)
library(dplyr)
library(survey)
library(srvyr)
library(stringr)
library(knitr)
library(DT)
library(ggplot2)
library(plotly)
library(scales)
library(forcats)

# Create cache directory
if (!dir.exists("cache_data")) {
  dir.create("cache_data")
}

knitr::opts_chunk$set(
  echo = TRUE,
  warning = TRUE,
  message = FALSE,
  fig.width = 10,
  fig.height = 6
)


# The smart_table() function; user supplies title text

smart_table <- function(data, title = NULL, pageLength = 10, col.names = NULL, ...) {
  
  # Print the title if provided
  if (!is.null(title)) {
    
      cat(title, 
        "\n\n")
    
    # cat("###", 
    #     title, 
    #     "\n\n")
    
  }
  
  if (knitr::is_html_output()) {
    
    # HTML → interactive DT table
    DT::datatable(
      data,
      colnames = col.names,
      options = list(
        pageLength = pageLength,
        autoWidth = TRUE
      ),
      ...
    )
    
  } else if (knitr::is_latex_output()) {
    
    # PDF → LaTeX table with booktabs
    knitr::kable(
      data,
      col.names = col.names,
      format = "latex",
      booktabs = TRUE,
      ...
    )
    
  } else if (knitr::pandoc_to("typst")) {
    
    # Typst → pipe table with bold headers + alternating row shading
    df <- data
    if (!is.null(col.names)) {
      colnames(df) <- col.names
    }
    
    # Bold headers
    colnames(df) <- paste0("**", colnames(df), "**")
    
    # Alternating row shading for Typst
    for (i in seq_len(nrow(df))) {
      if (i %% 2 == 0) {
        df[i, ] <- paste0("`#set fill(0.9)` ", df[i, ])
      }
    }
    
    knitr::kable(
      df,
      format = "pipe",
      ...
    )
    
  } else {
    
    # Fallback → plain text table
    knitr::kable(
      data,
      col.names = col.names,
      format = "simple",
      ...
    )
  }
}


```



# Data Collection and Processing

**Status Check:** This section will show whether chunks are executing and data is being processed.

```{r chunk-status}
cat("=== CHUNK EXECUTION STATUS ===\n")
cat("This chunk is running at:", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "\n")
cat("R session info: R version", R.version.string, "\n")
cat("Working directory:", getwd(), "\n")
cat("Cache directory exists:", dir.exists("cache_data"), "\n")
if (dir.exists("cache_data")) {
  cache_files <- list.files("cache_data")
  cat("Cache files found:", length(cache_files), "\n")
  if (length(cache_files) > 0) {
    cat("Cache files:", toString(cache_files), "\n")
  }
} else {
  cat("No cache directory found - will create during data download\n")
}
cat("=== STATUS CHECK COMPLETE ===\n\n")
```

## PUMS Data Extraction

```{r data-collection}
#| cache: true
#| echo: true
#| output: false
#| message: false



# Add time stamp and progress indicators
cat("=== DATA COLLECTION STARTED ===\n")
cat("Timestamp:", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "\n")
cat("Cache directory exists:", dir.exists("cache_data"), "\n")

# Check if cached raw data exists
if (file.exists("cache_data/raw_data.rds")) {
  cat("*** LOADING FROM CACHE ***\n")
  cat("Loading cached PUMS data...\n")
  
  start_time <- Sys.time()
  raw_data <- readRDS("cache_data/raw_data.rds")
  end_time <- Sys.time()
  
  tx_female_never_married <- raw_data$tx_female
  tx_male_all <- raw_data$tx_male
  rm(raw_data)
  
  cat("Cache load completed in", round(as.numeric(end_time - start_time), 2), "seconds\n")
  cat("Female data rows:", nrow(tx_female_never_married), "\n")
  cat("Male data rows:", nrow(tx_male_all), "\n")
} else {
  cat("*** DOWNLOADING FRESH DATA ***\n")
  cat("No cache found. Downloading PUMS data (this will take several minutes)...\n")
  cat("Download started at:", format(Sys.time(), "%H:%M:%S"), "\n")
  
  # Get PUMS data for Texas females
  cat("Downloading female data...\n")
  start_female <- Sys.time()
  tx_female_never_married <- get_pums(
    variables = c("SEX", "MAR", "OCCP", "PINCP", "PERNP", "AGEP", "COW"),
    state = "TX",
    survey = "acs5",
    year = 2022,
    recode = TRUE
  )
  end_female <- Sys.time()
  cat("Female download completed in", round(as.numeric(end_female - start_female), 1), "minutes\n")
  cat("Female data rows:", nrow(tx_female_never_married), "\n")
  
  # Get PUMS data for Texas males
  cat("Downloading male data...\n")
  start_male <- Sys.time()
  tx_male_all <- get_pums(
    variables = c("SEX", "MAR", "OCCP", "PINCP", "PERNP", "AGEP", "COW"),
    state = "TX", 
    survey = "acs5",
    year = 2022,
    recode = TRUE
  )
  end_male <- Sys.time()
  cat("Male download completed in", round(as.numeric(end_male - start_male), 1), "minutes\n")
  cat("Male data rows:", nrow(tx_male_all), "\n")
  
  # Cache the raw data
  cat("Saving to cache...\n")
  if (!dir.exists("cache_data")) {
    dir.create("cache_data")
    cat("Created cache_data directory\n")
  }
  
  saveRDS(list(
    tx_female = tx_female_never_married,
    tx_male = tx_male_all
  ), "cache_data/raw_data.rds")
  
  total_time <- as.numeric(Sys.time() - start_female)
  cat("*** DOWNLOAD COMPLETE ***\n")
  cat("Total download time:", round(total_time, 1), "minutes\n")
  cat("Raw data cached for future use.\n")
}

cat("=== DATA COLLECTION FINISHED ===\n")
cat("Proceeding to data filtering...\n\n")
```

## Data Filtering and Preparation

```{r data-filtering}
#| cache: true
#| echo: true
#| output: false
#| message: false


cat("=== DATA FILTERING STARTED ===\n")
cat("Timestamp:", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), "\n")

# Check if processed data exists
if (file.exists("cache_data/processed_data.rds")) {
  cat("*** LOADING PROCESSED DATA FROM CACHE ***\n")
  
  start_time <- Sys.time()
  processed <- readRDS("cache_data/processed_data.rds")
  end_time <- Sys.time()
  
  female_never_married <- processed$female_never_married
  male_all <- processed$male_all
  combined_data <- processed$combined_data
  rm(processed)
  
  cat("Processed data loaded in", round(as.numeric(end_time - start_time), 2), "seconds\n")
} else {
  cat("*** PROCESSING DATA FROM SCRATCH ***\n")
  cat("No processed cache found. Filtering data...\n")
  
  # Filter datasets using numeric codes
  # SEX: 1=Male, 2=Female | MAR: 5=Never married
  
  cat("Filtering female data...\n")
  cat("- Raw female rows:", nrow(tx_female_never_married), "\n")
  
  female_never_married <- tx_female_never_married %>%
    dplyr::filter(
      SEX == "2",        # Female
      MAR == "5",        # Never married
      AGEP >= 25 & AGEP <= 64,
      PERNP > 0,         # Has earnings
      OCCP != "000N",    # Exclude N/A occupations
      !is.na(OCCP),
      !is.na(PERNP)
    )
  
  cat("- Filtered female rows:", nrow(female_never_married), "\n")
  
  cat("Filtering male data...\n")
  cat("- Raw male rows:", nrow(tx_male_all), "\n")
  
  male_all <- tx_male_all %>%
    dplyr::filter(
      SEX == "1",        # Male
      AGEP >= 25 & AGEP <= 64,
      PERNP > 0,         # Has earnings
      OCCP != "000N",    # Exclude N/A occupations
      !is.na(OCCP),
      !is.na(PERNP)
    )
  
  cat("- Filtered male rows:", nrow(male_all), "\n")
  
  # Combine datasets
  cat("Combining datasets...\n")
  combined_data <- dplyr::bind_rows(
    female_never_married %>% dplyr::mutate(group = "Female_Never_Married"),
    male_all %>% dplyr::mutate(group = "Male_All")
  )
  
  cat("- Combined data rows:", nrow(combined_data), "\n")
  cat("- Groups in combined data:", toString(unique(combined_data$group)), "\n")
  
  # Cache processed data
  cat("Saving processed data to cache...\n")
  saveRDS(list(
    female_never_married = female_never_married,
    male_all = male_all,
    combined_data = combined_data
  ), "cache_data/processed_data.rds")
  
  cat("*** PROCESSING COMPLETE ***\n")
}

cat("=== DATA FILTERING FINISHED ===\n\n")

# Display sample sizes
sample_summary <- data.frame(
  Group = c("Never-Married Females", "All Males"),
  Sample_Size = c(nrow(female_never_married), nrow(male_all)),
  Age_Range = c("25-64", "25-64"),
  Criteria = c("Never married, positive earnings", "All marital status, positive earnings")
)


smart_table(sample_summary,
            title = "Sample Composition",
            col.names = c("Group", "Sample Size", "Age Range", "Selection Criteria"))


```

# Occupation Search and Query Functions

```{r search-functions}
# Function to search for specific occupations and their mean earnings
search_occupation <- function(search_term, data = female_never_married) {
  
  # Find matching occupations
  matching_occs <- data %>%
    dplyr::filter(stringr::str_detect(OCCP_label, stringr::regex(search_term, ignore_case = TRUE))) %>%
    dplyr::distinct(OCCP_label) %>%
    dplyr::arrange(OCCP_label)
  
  if (nrow(matching_occs) == 0) {
    cat("No occupations found matching '", search_term, "'\n", sep = "")
    return(NULL)
  }
  
  
  # Calculate stats for matching occupations
  occupation_stats <- data %>%
    dplyr::filter(stringr::str_detect(OCCP_label, stringr::regex(search_term, ignore_case = TRUE))) %>%
    srvyr::as_survey_design(weights = PWGTP) %>%
    dplyr::group_by(OCCP_label) %>%
    srvyr::summarise(
      count = srvyr::survey_total(),
      mean_earnings = srvyr::survey_mean(PERNP, na.rm = TRUE),
      median_earnings = srvyr::survey_median(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    dplyr::arrange(desc(mean_earnings))
  
  return(occupation_stats)
}


# Function to get detailed comparison for specific occupation
get_occupation_comparison <- function(occupation_pattern, data = combined_data) {
  
  filtered_data <- data %>%
    dplyr::filter(stringr::str_detect(OCCP_label, stringr::regex(occupation_pattern, ignore_case = TRUE)))
  
  if (nrow(filtered_data) == 0) {
    cat("No data found for occupation pattern: '", occupation_pattern, "'\n", sep = "")
    return(NULL)
  }
  
  # Check if we have both groups
  groups_present <- unique(filtered_data$group)
  
  result <- filtered_data %>%
    srvyr::as_survey_design(weights = PWGTP) %>%
    dplyr::group_by(group, OCCP_label) %>%
    srvyr::summarise(
      count = srvyr::survey_total(),
      mean_earnings = srvyr::survey_mean(PERNP, na.rm = TRUE),
      median_earnings = srvyr::survey_median(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    dplyr::arrange(OCCP_label, group)
  
  return(list(
    data = result,
    groups_present = groups_present,
    total_records = nrow(filtered_data)
  ))
}
```

# Occupation Discovery: Why Physician May Not Appear

Let's investigate specific medical occupations and their earnings:

```{r physician-investigation}

# Search for physician-related occupations
cat("=== SEARCHING FOR PHYSICIAN-RELATED OCCUPATIONS ===\n")

physician_results <- search_occupation("physician", female_never_married)

if (!is.null(physician_results)) {
  cat("Found", nrow(physician_results), "physician-related occupations for never-married females:\n\n")
  
  physician_formatted <- physician_results %>%
    dplyr::mutate(
      mean_earnings = dollar(mean_earnings),
      median_earnings = dollar(median_earnings),
      count = round(count)
    ) %>%
    dplyr::select(
      Occupation = OCCP_label,
      Count = count,
      `Mean Earnings` = mean_earnings,
      `Median Earnings` = median_earnings
    )
  
  smart_table(physician_formatted,
              title = "'Physician' Related Occupations Used (Never-Married Females)")
} else {
  cat("No physician occupations found in the data.\n")
}

# Also search for related medical terms
cat("\n=== SEARCHING FOR OTHER MEDICAL OCCUPATIONS ===\n")

medical_terms <- c("doctor", "medical", "surgeon", "practitioner")

for (term in medical_terms) {
  cat("\n=== Testing term: '", term, "' ===\n", sep = "")
  
  results <- search_occupation(term, female_never_married)
  
  cat("Results is NULL:", is.null(results), "\n")
  if (!is.null(results)) {
    cat("Results has", nrow(results), "rows\n")
  } else {
    cat("Search returned NULL for term:", term, "\n")
    next
  }
  
  if (!is.null(results) && nrow(results) > 0) {
    cat("Found ", nrow(results), " occupations matching '", term, "':\n", sep = "")
    top_result <- results %>% dplyr::slice_head(n = 20)
    
    cat("top_result created with", nrow(top_result), "rows\n")
    
    if (nrow(top_result) > 0) {
      cat("DEBUG: First few OCCP_label values:\n")
      for (i in 1:min(3, nrow(top_result))) {
        cat("Row", i, ": '", as.character(top_result$OCCP_label[i]), "'\n", sep = "")
      }
      cat("\n")
      
      for (i in 1:nrow(top_result)) {
        cat("- ", as.character(top_result$OCCP_label[i]), ": ", dollar(top_result$mean_earnings[i]), 
            " (n=", round(top_result$count[i]), ")\n", sep = "")
      }
    } else {
      cat("top_result has 0 rows\n")
    }
  } else {
    cat("No results found for term:", term, "\n")
  }
}

cat("\n=== End of medical terms search ===\n")

```

# Analysis Functions

```{r analysis-functions}
# Function to calculate pay gap using MEAN earnings and test significance
calculate_pay_gap <- function(data, occupation_filter = NULL) {
  
  if (!is.null(occupation_filter)) {
    filtered_data <- data %>%
      dplyr::filter(stringr::str_detect(OCCP_label, stringr::regex(occupation_filter, ignore_case = TRUE)))
  } else {
    filtered_data <- data
  }
  
  # Check data sufficiency
  if (nrow(filtered_data) < 10) return(NULL)
  
  groups_present <- unique(filtered_data$group)
  if (length(groups_present) < 2) return(NULL)
  
  # Create survey design and get stats
  tryCatch({
    svy_data <- filtered_data %>%
      srvyr::as_survey_design(weights = PWGTP)
    
    group_stats <- svy_data %>%
      dplyr::group_by(group) %>%
      srvyr::summarise(
        count = srvyr::survey_total(),
        mean_earnings = srvyr::survey_mean(PERNP, na.rm = TRUE),
        median_earnings = srvyr::survey_median(PERNP, na.rm = TRUE),
        .groups = "drop"
      )
    
    if (nrow(group_stats) >= 2) {
      # Find indices more carefully
      female_rows <- which(group_stats$group == "Female_Never_Married")
      male_rows <- which(stringr::str_detect(group_stats$group, "Male"))
      
      if (length(female_rows) > 0 && length(male_rows) > 0) {
        female_idx <- female_rows[1]  # Take first match
        male_idx <- male_rows[1]      # Take first match
        
        # *** FIX: Use MEAN earnings instead of median ***
        female_mean <- group_stats$mean_earnings[female_idx]
        male_mean <- group_stats$mean_earnings[male_idx]
        
        # Only proceed if we have valid numeric values
        if (is.numeric(female_mean) && is.numeric(male_mean) && 
            !is.na(female_mean) && !is.na(male_mean) && female_mean > 0) {
          
          # Calculate gaps using MEAN earnings (NOT median)
          mean_gap_dollars <- male_mean - female_mean
          mean_gap_percent <- ((male_mean - female_mean) / female_mean) * 100
          
          # Statistical test
          tryCatch({
            test_result <- survey::svyttest(PERNP ~ group, svy_data)
            p_value <- test_result$p.value
          }, error = function(e) {
            p_value <- NA
          })
          
          # Return results with MEAN fields (not median)
          return(list(
            occupation = ifelse(is.null(occupation_filter), "ALL OCCUPATIONS", occupation_filter),
            group_stats = group_stats,
            mean_gap_dollars = mean_gap_dollars,          # *** FIX: Use mean ***
            mean_gap_percent = round(mean_gap_percent, 1), # *** FIX: Use mean ***
            t_test_p_value = p_value,
            significant = !is.na(p_value) && p_value < 0.05,
            female_count = group_stats$count[female_idx],
            male_count = group_stats$count[male_idx]
          ))
        } else {
          cat("Invalid earnings data for calculation\n")
          return(NULL)
        }
      } else {
        cat("Could not find both female and male groups\n")
        return(NULL)
      }
    } else {
      cat("Insufficient group stats\n")
      return(NULL)
    }
  }, error = function(e) {
    cat("Error in calculate_pay_gap:", e$message, "\n")
    return(NULL)
  })
}
```

# Top Occupations Analysis (By Mean Earnings)

```{r top-occupations}
#| cache: true
#| echo: true
#| output: false
#| message: false

# Check if top occupations analysis exists
if (file.exists("cache_data/top_occupations.rds")) {
  top_occupations_female <- readRDS("cache_data/top_occupations.rds")
} else {
  # Calculate top occupations by MEAN earnings for never-married females
  top_occupations_female <- female_never_married %>%
    srvyr::as_survey_design(weights = PWGTP) %>%
    dplyr::group_by(OCCP_label) %>%
    srvyr::summarise(
      count = srvyr::survey_total(),
      mean_earnings = srvyr::survey_mean(PERNP, na.rm = TRUE),
      median_earnings = srvyr::survey_median(PERNP, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    dplyr::filter(count >= 30) %>%  # Filter for statistical reliability
    dplyr::arrange(desc(mean_earnings)) %>%  # Sort by MEAN earnings
    dplyr::slice_head(n = 20)
  
  saveRDS(top_occupations_female, "cache_data/top_occupations.rds")
}

# Create formatted table
top_occupations_formatted <- top_occupations_female %>%
  dplyr::mutate(
    mean_earnings = dollar(mean_earnings),
    median_earnings = dollar(median_earnings),
    count = round(count)
  ) %>%
  dplyr::select(
    Occupation = OCCP_label,
    `Sample Size` = count,
    `Mean Earnings` = mean_earnings,
    `Median Earnings` = median_earnings
  )

datatable(top_occupations_formatted,
          caption = "Top 20 Occupations by Mean Earnings (Never-Married Females)",
          options = list(pageLength = 20, scrollX = TRUE))
```

## Visualization: Top Occupations by Mean Earnings

```{r top-occupations-plot}
#| fig-cap: "Top 15 Occupations by Mean Earnings for Never-Married Females"

top_15_plot <- top_occupations_female %>%
  dplyr::slice_head(n = 15) %>%
  dplyr::mutate(
    OCCP_label = forcats::fct_reorder(OCCP_label, mean_earnings)
  ) %>%
  ggplot(aes(x = mean_earnings, y = OCCP_label)) +
  geom_col(fill = "steelblue", alpha = 0.8) +
  scale_x_continuous(labels = dollar_format()) +
  labs(
    title = "Top 15 Occupations by Mean Earnings",
    subtitle = "Never-Married Females, Ages 25-64, Texas",
    x = "Mean Annual Earnings",
    y = "Occupation"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    axis.text.y = element_text(size = 10)
  )

ggplotly(top_15_plot, tooltip = c("x", "y"))
```

# Overall Pay Gap Analysis (Mean Earnings)

```{r overall-analysis}
#| cache: true
#| echo: true
#| output: false
#| message: false


# Check if overall analysis exists
if (file.exists("cache_data/overall_gap.rds")) {
  overall_gap <- readRDS("cache_data/overall_gap.rds")
} else {
  overall_gap <- calculate_pay_gap(combined_data)
  saveRDS(overall_gap, "cache_data/overall_gap.rds")
}

if (!is.null(overall_gap) && !is.null(overall_gap$mean_gap_dollars)) {
  # Safely handle numeric values
  female_count_safe <- if(is.numeric(overall_gap$female_count)) comma(round(overall_gap$female_count)) else "N/A"
  male_count_safe <- if(is.numeric(overall_gap$male_count)) comma(round(overall_gap$male_count)) else "N/A"
  mean_gap_dollars_safe <- if(is.numeric(overall_gap$mean_gap_dollars)) dollar(round(overall_gap$mean_gap_dollars)) else "N/A"
  mean_gap_percent_safe <- if(is.numeric(overall_gap$mean_gap_percent)) paste0(overall_gap$mean_gap_percent, "%") else "N/A"
  
  overall_summary <- data.frame(
    Metric = c("Female Sample Size", "Male Sample Size", 
               "Mean Gap ($)", "Mean Gap (%)", 
               "P-value", "Statistically Significant"),
    Value = c(
      female_count_safe,
      male_count_safe,
      mean_gap_dollars_safe,
      mean_gap_percent_safe,
      ifelse(is.na(overall_gap$t_test_p_value), "N/A", 
             format(overall_gap$t_test_p_value, scientific = TRUE, digits = 3)),
      ifelse(overall_gap$significant, "Yes", "No")
    )
  )
  
  smart_table(overall_summary,
        title = "Overall Pay Gap: Never-Married Females vs All Males (Texas, Age 25-64) - MEAN EARNINGS",
        col.names = c("Metric", "Value"))
  
  
} else {
  cat("ERROR: Could not calculate overall pay gap. Check data and calculation function.\n")
  cat("Debug info:\n")
  cat("- overall_gap is null:", is.null(overall_gap), "\n")
  if (!is.null(overall_gap)) {
    cat("- mean_gap_dollars is null:", is.null(overall_gap$mean_gap_dollars), "\n")
    cat("- Structure of overall_gap:\n")
    str(overall_gap)
  }
}
```

# Occupation-Specific Pay Gap Analysis (Mean Earnings)

```{r occupation-analysis}
#| cache: true
#| echo: true



# Check if occupation analysis exists
if (file.exists("cache_data/occupation_results.rds")) {
  occupation_results <- readRDS("cache_data/occupation_results.rds")
} else {
  
  
  # Analyze specific occupations
occupations_to_test <- c("Physician", "Surgeon", "Lawyer", "Accountant", 
                        "Engineer", "Teacher", "Nurse", "Manager", 
                        "Dentist", "Pharmacist")  # Added these two

occupation_results <- list()
for (occ in occupations_to_test) {
  cat("Testing occupation:", occ, "\n")
  
  # Check how many records match this occupation
  matching_records <- combined_data %>%
    dplyr::filter(stringr::str_detect(OCCP_label, stringr::regex(occ, ignore_case = TRUE)))
  
  cat("- Total matching records:", nrow(matching_records), "\n")
  
  if (nrow(matching_records) > 0) {
    groups_in_data <- unique(matching_records$group)
    cat("- Groups present:", toString(groups_in_data), "\n")
    
    group_counts <- matching_records %>%
      dplyr::count(group)
    print(group_counts)
  }
  
  gap_result <- calculate_pay_gap(combined_data, occ)
  if (!is.null(gap_result)) {
    occupation_results[[occ]] <- gap_result
    cat("- Result: SUCCESS - added to results\n")
  } else {
    cat("- Result: FAILED - calculate_pay_gap returned NULL\n")
  }
  cat("\n")
}
  
  # # Analyze specific occupations
  # occupations_to_test <- c("Physician", "Surgeon", "Dentist", "Pharmacist", "Lawyer", "Accountant", 
  #                         "Engineer", "Teacher", "Nurse", "Manager")
  # 
  # occupation_results <- list()
  # for (occ in occupations_to_test) {
  #   gap_result <- calculate_pay_gap(combined_data, occ)
  #   if (!is.null(gap_result)) {
  #     occupation_results[[occ]] <- gap_result
  #   }
  # }
  
  saveRDS(occupation_results, "cache_data/occupation_results.rds")
}


# Create summary table
if (length(occupation_results) > 0) {
  summary_df <- data.frame(
    Occupation = names(occupation_results),
    Female_Count = sapply(occupation_results, function(x) comma(round(x$female_count))),
    Male_Count = sapply(occupation_results, function(x) comma(round(x$male_count))),
    Mean_Gap_Percent = sapply(occupation_results, function(x) paste0(x$mean_gap_percent, "%")),
    P_Value = sapply(occupation_results, function(x) 
      ifelse(is.na(x$t_test_p_value), "N/A", round(x$t_test_p_value, 4))),
    Significant = sapply(occupation_results, function(x) 
      ifelse(x$significant, "Yes", "No"))
  )
  
  datatable(summary_df,
            caption = "Pay Gap Analysis by Occupation (MEAN EARNINGS)",
            colnames = c("Occupation", "Female Sample", "Male Sample", 
                        "Mean Gap (%)", "P-Value", "Significant?"),
            options = list(pageLength = 10, scrollX = TRUE)) %>%
    formatStyle("Significant", 
                backgroundColor = styleEqual("Yes", "lightcoral"))
}
```

# Custom Occupation Queries

This section allows you to explore specific occupations that may not appear in the top 20:

```{r custom-queries}
# Function to query and display specific occupation
query_occupation <- function(search_term) {
  cat("### Searching for:", search_term, "\n\n")
  
  # Get female results
  female_results <- search_occupation(search_term, female_never_married)
  
  if (!is.null(female_results) && nrow(female_results) > 0) {
    cat("**Never-Married Females:**\n")
    female_table <- female_results %>%
      dplyr::mutate(
        mean_earnings = dollar(mean_earnings),
        count = round(count)
      ) %>%
      dplyr::select(Occupation = OCCP_label, Count = count, `Mean Earnings` = mean_earnings)
    
    smart_table(female_table)

    
    # Get comparison with males
    comparison <- get_occupation_comparison(search_term, combined_data)
    if (!is.null(comparison) && nrow(comparison$data) > 0) {
      cat("\n**Comparison with Males:**\n")
      comp_table <- comparison$data %>%
        dplyr::mutate(
          mean_earnings = dollar(mean_earnings),
          count = round(count)
        ) %>%
        dplyr::select(Occupation = OCCP_label, Group = group, Count = count, `Mean Earnings` = mean_earnings)
      
      smart_table(comp_table)
      
    }
  } else {
    cat("No results found for '", search_term, "'\n", sep = "")
  }
  
  cat("\n---\n\n")
}

# Query specific occupations of interest
query_occupation("Physician")
query_occupation("Doctor")
query_occupation("Surgeon")
query_occupation("Dentist")
query_occupation("Pharmacist")

# Check sample sizes for dental/pharmacy occupations
dental_check <- search_occupation("Dentist", female_never_married)
if (!is.null(dental_check)) {
  cat("Dentist sample size:", round(dental_check$count[1]), "\n")
}

pharmacy_check <- search_occupation("Pharmacist", female_never_married) 
if (!is.null(pharmacy_check)) {
  cat("Pharmacist sample size:", round(pharmacy_check$count[1]), "\n")
}
```

# Detailed Results by Occupation (Mean Earnings)

```{r detailed-results}
# Show detailed results for each occupation using MEAN earnings
for (occ_name in names(occupation_results)) {
  result <- occupation_results[[occ_name]]
  
  cat("###", occ_name, "\n\n")
  
  # Debug: Show what the function actually returned
  cat("**Debug - Function Return for", occ_name, ":**\n")
  cat("- Object class:", class(result), "\n")
  cat("- Fields present:", toString(names(result)), "\n")
  cat("- mean_gap_dollars present:", "mean_gap_dollars" %in% names(result), "\n")
  cat("- mean_gap_dollars value:", result$mean_gap_dollars, "\n")
  cat("- mean_gap_dollars is numeric:", is.numeric(result$mean_gap_dollars), "\n")
  cat("- Group stats rows:", if("group_stats" %in% names(result)) nrow(result$group_stats) else "N/A", "\n")
  
  if ("group_stats" %in% names(result) && !is.null(result$group_stats)) {
    cat("- Groups in stats:", toString(result$group_stats$group), "\n")
  }
  cat("\n")
  
  # Safely handle the indices and values
  if ("group_stats" %in% names(result) && !is.null(result$group_stats) && nrow(result$group_stats) > 0) {
    female_idx <- which(result$group_stats$group == "Female_Never_Married")
    male_idx <- which(result$group_stats$group != "Female_Never_Married")
    
    cat("- Female index found:", toString(female_idx), "\n")
    cat("- Male index found:", toString(male_idx), "\n")
    
    if (length(female_idx) > 0 && length(male_idx) > 0) {
      # Safely extract values
      female_count <- if(is.numeric(result$female_count)) round(result$female_count) else 0
      male_count <- if(is.numeric(result$male_count)) round(result$male_count) else 0
      
      female_earnings <- if(length(female_idx) > 0) result$group_stats$mean_earnings[female_idx] else NA
      male_earnings <- if(length(male_idx) > 0) result$group_stats$mean_earnings[male_idx] else NA
      
      cat("- Female earnings:", female_earnings, "\n")
      cat("- Male earnings:", male_earnings, "\n\n")
      
      detailed_table <- data.frame(
        Group = c("Never-Married Females", "All Males"),
        Sample_Size = c(female_count, male_count),
        Mean_Earnings = c(
          if(is.numeric(female_earnings)) dollar(female_earnings) else "N/A",
          if(is.numeric(male_earnings)) dollar(male_earnings) else "N/A"
        )
      )
      
      
      smart_table(detailed_table,
                  col.names = c("Group", "Sample Size", "Mean Earnings"))
      
      
      cat("\n**Pay Gap Analysis (Mean Earnings):**\n")
      
      # Safely handle gap calculations
      if (is.numeric(result$mean_gap_dollars) && is.numeric(result$mean_gap_percent)) {
        cat("- Mean Gap: ", dollar(round(result$mean_gap_dollars)), 
            " (", result$mean_gap_percent, "%)\n", sep = "")
      } else {
        cat("- Mean Gap: Unable to calculate\n")
        cat("  - Reason: mean_gap_dollars is", class(result$mean_gap_dollars), 
            ", mean_gap_percent is", class(result$mean_gap_percent), "\n")
      }
      
      cat("- P-value:", ifelse(is.na(result$t_test_p_value), "N/A", 
                              format(result$t_test_p_value, scientific = TRUE, digits = 3)), "\n")
      cat("- Statistically Significant:", ifelse(result$significant, "**Yes**", "No"), "\n\n")
    } else {
      cat("Error: Could not find data for both groups in", occ_name, "\n")
      cat("- Available groups:", toString(result$group_stats$group), "\n\n")
    }
  } else {
    cat("Error: No group_stats available for", occ_name, "\n\n")
  }
  
  cat("---\n\n")
}
```

# Alternative Analysis: Never-Married Comparison (Mean Earnings)

```{r never-married-comparison}
#| cache: true
#| echo: true
#| output: false
#| message: false

# Check if never-married comparison exists
if (file.exists("cache_data/comparable_analysis.rds")) {
  comparable_results <- readRDS("cache_data/comparable_analysis.rds")
  comparable_gap <- comparable_results$comparable_gap
} else {
  # Get never-married males
  tx_male_never_married <- get_pums(
    variables = c("SEX", "MAR", "OCCP", "PINCP", "PERNP", "AGEP", "COW"),
    state = "TX",
    survey = "acs5",
    year = 2022,
    recode = TRUE
  )
  
  male_never_married <- tx_male_never_married %>%
    dplyr::filter(
      SEX == "1",
      MAR == "5", 
      AGEP >= 25 & AGEP <= 64,
      PERNP > 0,
      OCCP != "000N",
      !is.na(OCCP),
      !is.na(PERNP)
    )
  
  # Combine for comparison
  comparable_data <- dplyr::bind_rows(
    female_never_married %>% dplyr::mutate(group = "Female_Never_Married"),
    male_never_married %>% dplyr::mutate(group = "Male_Never_Married")
  )
  
  comparable_gap <- calculate_pay_gap(comparable_data)
  
  saveRDS(list(comparable_gap = comparable_gap), "cache_data/comparable_analysis.rds")
}

# Create comparison table with safe handling
if (!is.null(comparable_gap) && !is.null(overall_gap) && 
    !is.null(overall_gap$mean_gap_percent) && !is.null(comparable_gap$mean_gap_percent)) {
  
  # Safely format values
  overall_gap_pct <- if(is.numeric(overall_gap$mean_gap_percent)) paste0(overall_gap$mean_gap_percent, "%") else "N/A"
  comparable_gap_pct <- if(is.numeric(comparable_gap$mean_gap_percent)) paste0(comparable_gap$mean_gap_percent, "%") else "N/A"
  
  overall_pval <- if(!is.na(overall_gap$t_test_p_value)) format(overall_gap$t_test_p_value, scientific = TRUE, digits = 3) else "N/A"
  comparable_pval <- if(!is.na(comparable_gap$t_test_p_value)) format(comparable_gap$t_test_p_value, scientific = TRUE, digits = 3) else "N/A"
  
  comparison_summary <- data.frame(
    Comparison = c("Never-Married Females vs All Males", 
                   "Never-Married Females vs Never-Married Males"),
    Mean_Gap_Percent = c(overall_gap_pct, comparable_gap_pct),
    P_Value = c(overall_pval, comparable_pval),
    Significant = c(
      ifelse(overall_gap$significant, "Yes", "No"),
      ifelse(comparable_gap$significant, "Yes", "No")
    )
  )
  
  
  smart_table(comparison_summary,
        caption = "Comparison of Different Analysis Approaches (MEAN EARNINGS)",
        col.names = c("Comparison", "Mean Gap (%)", "P-Value", "Significant?"))

  
} else {
  cat("Could not create comparison table due to missing data.\n")
  cat("Debug info:\n")
  cat("- overall_gap is null:", is.null(overall_gap), "\n")
  cat("- comparable_gap is null:", is.null(comparable_gap), "\n")
  if (!is.null(overall_gap)) {
    cat("- overall_gap$mean_gap_percent is null:", is.null(overall_gap$mean_gap_percent), "\n")
  }
  if (!is.null(comparable_gap)) {
    cat("- comparable_gap$mean_gap_percent is null:", is.null(comparable_gap$mean_gap_percent), "\n")
  }
}
```

# Cache Management

```{r cache-info}
#| echo: true

# Display cache information
cache_files <- list.files("cache_data", full.names = TRUE)
if (length(cache_files) > 0) {
  cat("Cached files:\n")
  file_info <- file.info(cache_files)
  cache_summary <- data.frame(
    File = basename(cache_files),
    Size_MB = round(file_info$size / 1024^2, 2),
    Modified = format(file_info$mtime, "%Y-%m-%d %H:%M")
  )
 
  
  smart_table(cache_summary)
  
  
  total_size <- round(sum(file_info$size) / 1024^2, 1)
  cat("\nTotal cache size:", total_size, "MB\n")
  cat("To refresh data: delete 'cache_data' folder and re-render\n")
} else {
  cat("No cache files found.\n")
}
```

# Debug Information

```{r debug-info}
#| echo: true

# Debug section to help troubleshoot calculation issues
cat("=== DEBUG INFORMATION ===\n")
cat("Combined data dimensions:", nrow(combined_data), "rows,", ncol(combined_data), "columns\n")
cat("Groups in combined data:", toString(unique(combined_data$group)), "\n")

# Check a small sample calculation manually
if (nrow(combined_data) > 0) {
  sample_calc <- combined_data %>%
    dplyr::group_by(group) %>%
    dplyr::summarise(
      count = n(),
      mean_earnings = mean(PERNP, na.rm = TRUE),
      .groups = "drop"
    )
  
  cat("\nSimple group summary (without survey weights):\n")
  
  smart_table(sample_calc)
  
  
  # Test the calculate_pay_gap function step by step
  cat("\n=== TESTING calculate_pay_gap FUNCTION ===\n")
  
  # Step 1: Check data
  cat("Step 1 - Data check:\n")
  cat("- Rows in combined_data:", nrow(combined_data), "\n")
  cat("- Groups present:", toString(unique(combined_data$group)), "\n")
  
  # Step 2: Try survey design
  cat("\nStep 2 - Survey design test:\n")
  tryCatch({
    test_svy <- combined_data %>%
      srvyr::as_survey_design(weights = PWGTP)
    cat("- Survey design created successfully\n")
    
    # Step 3: Try group stats
    cat("\nStep 3 - Group stats test:\n")
    test_group_stats <- test_svy %>%
      dplyr::group_by(group) %>%
      srvyr::summarise(
        count = srvyr::survey_total(),
        mean_earnings = srvyr::survey_mean(PERNP, na.rm = TRUE),
        .groups = "drop"
      )
    
    cat("- Group stats calculated successfully\n")
    
    smart_table(test_group_stats)
    
    
    # Step 4: Test group indexing
    cat("\nStep 4 - Group indexing test:\n")
    female_rows <- which(test_group_stats$group == "Female_Never_Married")
    male_rows <- which(stringr::str_detect(test_group_stats$group, "Male"))
    
    cat("- Female rows found:", toString(female_rows), "\n")
    cat("- Male rows found:", toString(male_rows), "\n")
    
    if (length(female_rows) > 0 && length(male_rows) > 0) {
      female_idx <- female_rows[1]
      male_idx <- male_rows[1]
      
      female_mean <- test_group_stats$mean_earnings[female_idx]
      male_mean <- test_group_stats$mean_earnings[male_idx]
      
      cat("- Female mean earnings:", female_mean, "\n")
      cat("- Male mean earnings:", male_mean, "\n")
      cat("- Female mean is numeric:", is.numeric(female_mean), "\n")
      cat("- Male mean is numeric:", is.numeric(male_mean), "\n")
      cat("- Female mean > 0:", female_mean > 0, "\n")
      cat("- Male mean > 0:", male_mean > 0, "\n")
      
      if (is.numeric(female_mean) && is.numeric(male_mean) && 
          !is.na(female_mean) && !is.na(male_mean) && female_mean > 0) {
        
        mean_gap_dollars <- male_mean - female_mean
        mean_gap_percent <- ((male_mean - female_mean) / female_mean) * 100
        
        cat("- Gap calculation successful:\n")
        cat("  - Gap in dollars:", mean_gap_dollars, "\n")
        cat("  - Gap in percent:", mean_gap_percent, "\n")
      } else {
        cat("- Gap calculation FAILED: Invalid earnings data\n")
      }
    } else {
      cat("- Gap calculation FAILED: Could not find both groups\n")
    }
    
  }, error = function(e) {
    cat("Error in survey calculation:", e$message, "\n")
  })
  
  # Step 5: Test the actual function
  cat("\n=== TESTING ACTUAL FUNCTION ===\n")
  test_result <- calculate_pay_gap(combined_data)
  if (!is.null(test_result)) {
    cat("Function returned an object with fields:\n")
    cat("- Fields present:", toString(names(test_result)), "\n")
    cat("- mean_gap_dollars present:", "mean_gap_dollars" %in% names(test_result), "\n")
    if ("mean_gap_dollars" %in% names(test_result)) {
      cat("- mean_gap_dollars value:", test_result$mean_gap_dollars, "\n")
      cat("- mean_gap_dollars is null:", is.null(test_result$mean_gap_dollars), "\n")
    }
  } else {
    cat("Function returned NULL\n")
  }
  
} else {
  cat("No data in combined_data to analyze!\n")
}
```

# Methodologies (Mean Earnings Analysis)

Based on the PUMS data analysis using **mean earnings** for Texas working adults (ages 25-64):

## Why Physician May Not Appear in Top 20:

1. **Small Sample Size:** Physician occupations may have fewer than 30 never-married females, excluding them from the reliability filter
2. **Occupation Coding:** Medical professionals may be coded under more specific titles (e.g., "Family medicine physicians", "Internal medicine physicians")
3. **Mean vs Median:** Using mean earnings captures high earners better but may be affected by outliers
4. **Geographic Distribution:** Physicians may be concentrated in certain areas, affecting representation in the sample

## Analysis Focus:

- **Mean Income:** Captures full earning potential including high earners
- **Statistical Significance:** Proper survey-weighted testing
- **Occupation Search:** Custom queries to find specific professions
- **Sample Size Requirements:** Minimum 30 observations for reliable estimates

## Methodology:

- All pay gap calculations use **mean earnings** rather than median
- Survey weights account for complex sampling design
- Custom search functions help identify why specific occupations may be missing

---

*Report generated on `r Sys.Date()` using R and Quarto - Analysis based on MEAN EARNINGS*

----

