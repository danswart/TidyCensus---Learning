---
title: "TidyCensus Learning Guide"
subtitle: ""
description: ""
authors: 
  - name: "Dan Swart, CPA (ret)"
  - name: "Claude Sonnet 4.5"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # Hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: true
    include-in-header:
      - text: 
          <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Cabin&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Schoolbell&display=swap" rel="stylesheet">
      - header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 16pt
    mainfont: "Cabin"
  

    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px



  # docx:
  #   highlight-style: github
  #   fig_caption: true



editor: source

quarto:
  render:
    cache-refresh: true


# for .qmd filesd
execute:
  echo: true
  message: false
  warning: false
  eval: true
  fig-width: 12
  fig-height: 10


# for .rmd files
knitr:
  opts_chunk:
    echo: true
    error: false
    warning: false
    message: false
    cache: false


---


```{r}
#| label: setup
#| include: false


# install.packages(c("mapview", "survey", "srvyr", "arcgislayers"))

# census_api_key("95496766c51541ee6f402c1e1a8658581285b759", install = TRUE, overwrite = TRUE)


# # load libraries - NOT NEEDED


# Force dplyr's select to take precedence
select <- dplyr::select
filter <- dplyr::filter

# Options
options(scipen = 999)
options(qic.clshade = T) # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.linecol = 'black') # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.signalcol = "firebrick") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.targetcol = "purple") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(DT.options = list(dom = 'pBlfrti')) # Add buttons, filtering, and top (t) pagination controls
options(shiny.maxRequestSize = 50 * 1024^2) # Set upload maximum to 50 MB
options(tigris_use_cache = TRUE)
options(device = "RStudioGD") 


# Flextable defaults:
flextable::set_flextable_defaults(
  font.size = 14, 
  font.family = "Cabin",
  font.color = "black",
  table.layout = "fixed",
  border.color = "darkgray",
  padding.top = 3, padding.bottom = 3,
  padding.left = 4, padding.right = 4,
  line_spacing = 1.3,
  digits = 2,
  decimal.mark = ".",
  big.mark = " ",
  na_str = "<na>",
  post_process_html = identity,
  post_process_docx = identity
)


#
# # Sample Code:
# flextable::flextable(violations) |>
 #  flextable::set_header_labels(
 #    Variable = "Variable",
 #    Measurement = "Measurement",
 #    Likely_Impact = "Likely Impact"
 #  ) |>
#    flextable::add_header_lines(values = "Frequent Violations of Scientific Method in Current So-Called 'Equity' Research") |>
#   flextable::color(i = 1, color = "blue", part = "header") |>
#   flextable::italic(i = 1, part = "header") |>
#   flextable::align(i = 1, align = "center", part = "header") |>
#   flextable::fontsize(i = 1, size = 14, part = "header") |>
#   flextable::bg(i = 1, bg = "white", part = "header") |>
#   flextable::bg(i = 2, bg = "palegreen", part = "header") |>
#   flextable::bold(i = 1:2, part = "header") |>
#   flextable::bold(i = 1:7, j = 1, part = "body") |>
#   ftExtra::colformat_md() |> 
#   flextable::autofit()
  

# Flextable built-in themes:
  # flextable::theme_alafoli()	|>  # BLAH
  # flextable::theme_apa()  # THIS IS NICE
  # flextable::theme_booktabs() |>  # NICE, MORE COMPACT
  # flextable::theme_box() |>   # OK, INCLUDES CELL BORDERS
  # flextable::theme_tron() |>  # 'DARK MODE' BLUE TEXT
  # flextable::theme_tron_legacy() |>   # 'DARK MODE' YELLOW TEXT
  # flextable::theme_vader() |>    # 'DARK MODE' WHITE TEXT
  # flextable::theme_vanilla() |>   # NOT SPECIAL
  # flextable::theme_zebra()	|>
  #

# Flextable titles:
  # flextable::colformat_double(j = c("Mean", "SD", "N"), big.mark = ",", digits = 1) |>
  # flextable::flextable(variance_comparison) |>
  #  flextable::add_header_lines(values = "The Within-Group vs Between-Group Variance Problem") |>

# Flextable Title theming at table-level:
  #  flextable::color(i = 1, color = "blue", part = "header") |>
  #  flextable::italic(i = 1, part = "header") |>
  #  flextable::align(i = 1, align = "center", part = "header") |>
  #  flextable::fontsize(i = 1, size = 14, part = "header") |>
  #  flextable::bg(i = 1, bg = "white", part = "header") |>

# Flextable standard table background colors:
  #  flextable::bg(i = 2, bg = "palegreen", part = "header") |>
  

# Flextable reading markdown:
  #  ftExtra::colformat_md() |> 

# Flextable auto-sizing cell widths:
  #  flextable::autofit() 
 
 # Flextable background based on SPECIFIC cell contents:
  #
  # flextable::bg(i = ~ Impact_on_Validity == "High", j = "Impact_on_Validity", bg = "#ffcccc") |>
 # flextable::bg(i = ~ Impact_on_Validity == "Medium", j = "Impact_on_Validity", bg = "#ffffcc") |>
  #
  # 
  # Apply yellow background to any cell containing "Yes":

  # for (col in base::names(hypotheses_data)) {
  #   yes_rows <- base::which(hypotheses_data[[col]] == "Yes")
  #   if (base::length(yes_rows) > 0) {
  #     ft <- ft |>
  #       flextable::bg(i = yes_rows, j = col, bg = "yellow", part = "body")
  #   }
  # } 
  #
  # Apply to last row of table:
  #
  #



# Set global theme for consistent plots
ggplot2::theme_set(
  ggplot2::theme_minimal(base_size = 20) +
    ggplot2::theme(
      plot.title.position = "plot",
      plot.title = ggtext::element_textbox_simple(
        family = "Cabin",
        face = "bold",
        color = "darkgreen",
        size = 26,
        fill = "yellow",
        lineheight = 1.2,
        padding = ggplot2::margin(5.5, 5.5, 0.0, 5.5),
        margin = ggplot2::margin(0, 0, 5.5, 0)
      ),
      plot.subtitle = ggtext::element_textbox_simple(
        family = "Cabin",
        color = "darkgreen",
        face = "bold",
        size = 24,
        fill = "yellow",
        lineheight = 1.2,
        padding = ggplot2::margin(5.5, 5.5, 5.5, 5.5),
        margin = ggplot2::margin(10.5, 0, 5.5, 0)
      ),
      plot.caption = ggtext::element_markdown(
        family = "Cabin",
        size = 22,
        hjust = 1,
        color = "darkblue",
        face = "italic",
        fill = "yellow",
        lineheight = 1.0
      ),
      axis.text.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20,
        angle = 45,
        hjust = 1
      ),
        # ggplot2::element_blank(),
      axis.title.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20),
        # ggplot2::element_blank(),
      axis.text.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20,
        angle = 45,
        hjust = 1
      ),
        # ggplot2::element_blank(),
      axis.title.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20),
        # ggplot2::element_blank(),
      strip.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black",
        size = ggplot2::rel(1.1),
        face = "italic",
        margin = ggplot2::margin(2, 0, 0.5, 0, "lines")
      ),
      axis.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black"),
      panel.background = ggplot2::element_rect(fill = "white", color = NA),
      plot.background = ggplot2::element_rect(fill = "white", color = NA),
      legend.position = "none",
      panel.spacing.x = grid::unit(1.5, "cm"),
      panel.spacing.y = grid::unit(1.5, "cm"),
      plot.margin = ggplot2::margin(20, 20, 20, 20, "pt")
    )
)



  
# Set seed for reproducibility
base::set.seed(123)

```


```{r}
#| label: libraries

library(tidyverse)
library(tidycensus)
library(DT)
library(htmlwidgets)


```

# Levels of Census Data


### üìç Geographies available in PUMS

    Nationwide (United States as a whole)

    States, District of Columbia, and Puerto Rico

        Each state has its own PUMS data.

    Public Use Microdata Areas (PUMAs)

        Minimum population: 100,000+

        Smallest geography in PUMS

üö´ What PUMS does not cover

    Counties

    Places (cities, towns)

    Census tracts or block groups

    School districts, ZIP codes, or congressional districts
    


![](img/tidycensus_geographies.png){width=100% height=100% fig-align="left"}


![](img/census_diagram.png){width=100% height=100% fig-align="left"}



![](img/adaptive_design.png){width=100% height=100% fig-align="left"}


# Building a TidyCensus Research Workflow

## Initial Search Strategy

### Goal:  Combine the following characteristics for comparison of female and male earnings, by profession

Characteristics of Interest:  earnings √ó sex √ó marital status x occupation x years of experience

The Census Bureau typically organizes tables around 1-2 main dimensions, not five simultaneously.

(***earnings*** √ó sex √ó marital status x occupation x years of experience)


1. Search one by one for both concept AND label variables:

```{r}

# Retrieve by loading the four variables (columns) from acs5 dataframe 

all_vars_acs5 <- tidycensus::load_variables(2023, "acs5")

# Look for any mention of your variable across both fields
acs5_earnings_vars <- all_vars_acs5 %>%
  filter(str_detect(tolower(concept), "earn|income") | 
         str_detect(tolower(label), "earn|income"))

  glimpse(acs5_earnings_vars)
  

# Create the datatable (client-side)
dt_table <- datatable(
  acs5_earnings_vars,
  options = list(
    pageLength = 10,   # rows per page
    scrollX = TRUE     # horizontal scroll
  )
)

# # Save as HTML in your home directory
# saveWidget(dt_table, file = "~/acs5_earnings_vars_tbl.html", selfcontained = TRUE)




# Check what concepts exist
acs5_earnings_concepts <- acs5_earnings_vars %>% 
  distinct(concept)

  glimpse(acs5_earnings_concepts)


# Check what labels exist
earnings_labels <- acs5_earnings_vars %>% 
  distinct(label) 

  glimpse(earnings_labels)

```

Results:  8670 obs. of 4 variables from 28,261 total



(earnings √ó ***sex*** √ó marital status x occupation x years of experience)

```{r}

# Retrieve by loading the four variables (columns) from acs5 dataframe 

all_vars_acs5 <- tidycensus::load_variables(2023, "acs5")

# Look for any mention of your variables across both fields
sex_vars <- all_vars_acs5 %>%
  filter(str_detect(tolower(concept), "sex") | 
         str_detect(tolower(label), "sex"))

  glimpse(sex_vars)
  
  
# Check what concepts exist
sex_concepts <- sex_vars %>% 
  distinct(concept)

  glimpse(sex_concepts)


# Check what labels exist for earnings
sex_labels <- sex_vars %>% 
  distinct(label) 

  glimpse(sex_labels)

```

Results:  6845 obs. of 4 variables



(earnings √ó sex √ó ***marital status*** x occupation x years of experience)

```{r}

# Retrieve by loading the four variables (columns) from acs5 dataframe 

all_vars_acs5 <- tidycensus::load_variables(2023, "acs5")

# Look for any mention of your characteristics across both variables
marital_vars <- all_vars_acs5 %>%
  filter(str_detect(tolower(concept), "marital") | 
         str_detect(tolower(label), "marital"))

  glimpse(marital_vars)
  
  
# Check what concepts exist
marital_concepts <- marital_vars %>% 
  distinct(concept)

  glimpse(marital_concepts)


# Check what labels exist
marital_labels <- marital_vars %>% 
  distinct(label) 

  glimpse(marital_labels)

```

Results:  918 obs. of 4 variables




(earnings √ó sex √ó marital status x ***occupation*** x years of experience)

```{r}

# Retrieve by loading the four variables (columns) from acs5 dataframe 

all_vars_acs5 <- tidycensus::load_variables(2023, "acs5")

# Look for any mention of your characteristics across both variables
occupation_vars <- all_vars_acs5 %>%
  filter(str_detect(tolower(concept), "occupation") | 
         str_detect(tolower(label), "occupation"))

  glimpse(occupation_vars)
  
  
# Check what concepts exist
occupation_concepts <- occupation_vars %>% 
  distinct(concept)

  glimpse(occupation_concepts)


# Check what labels exist
occupation_labels <- occupation_vars %>% 
  distinct(label) 

  glimpse(occupation_labels)

```

Results:  5843 obs. of 4 variables




(earnings √ó sex √ó marital status x occupation x ***years of experience***)

```{r}

# Retrieve by loading the four variables (columns) from acs5 dataframe 
all_vars_acs5 <- tidycensus::load_variables(2023, "acs5")

# Look for any mention of your characteristics across both variables
experience_vars <- all_vars_acs5 %>%
  filter(str_detect(tolower(concept), "experience") | 
         str_detect(tolower(label), "experience"))

  glimpse(experience_vars)
  
  
# Check what concepts exist
experience_concepts <- experience_vars %>% 
  distinct(concept)

  glimpse(experience_concepts)


# Check what labels exist
experience_labels <- experience_vars %>% 
  distinct(label) 

  glimpse(experience_labels)

```

Results:  1295 obs. of 4 variables




## Explored Individual Components

* B12001: Sex by Marital Status ‚úì (found female never-married counts)  

* B20017: Sex by Earnings ‚úì (found male/female earnings)

* But no table combined both ‚úó

## The Data Discovery Process - How I Navigated Unknown Tables

### 1. Pattern Recognition in Census Table Numbering

I knew the Census Bureau uses systematic prefixes:

B = Base detailed tables  
S = Subject tables (pre-calculated percentages)  
B12xxx = Marital status tables  
B20xxx = Earnings/income tables  
B15xxx = Education tables  





### 2. Concept-Based Searching
Instead of guessing table numbers, I searched by concepts:

```{r}
#| eval: true


# Start broad - what tables mention earnings AND marital status?
all_vars_acs5 %>%
  filter(str_detect(concept, "earning") & 
         str_detect(concept, "marital"))

# When that failed, search separately
all_vars_acs5 %>%
  filter(str_detect(concept, "marital"))

```


### The "Show Me Everything" Approach

When concept searches failed, I used table structure exploration:

```{r}
#| eval: true

# See ALL variables in a promising table
b07008_all <- all_vars_acs5 %>%
  filter(str_starts(name, "B07008"))

# Look at first 10-20 to understand the pattern
print(b07008_all, n = 30)

```


### Pattern Detection Within Tables


ACS tables follow predictable patterns:

* Variables ending in _001 = Total

* Male sections come before female sections

* Hierarchical structure shown by !! separators

Example from B12001:

```{r}
#| eval: true

# B12001_001: Total
# B12001_002: Male
# B12001_003-010: Male categories
# B12001_011: Female  
# B12001_012-019: Female categories

```


### The "Which Tables Have My Variable?" Technique

When I found "never married" existed, I asked: where else does it appear?


```{r}
#| eval: true

# Find all tables with "never married"
never_married_any <- all_vars_acs5 %>%
  filter(str_detect(label, "never married")) %>%
  mutate(table = str_extract(name, "^[A-Z][0-9]+")) %>%
  count(table, sort = TRUE)

```


### Table Discovery by Counting

The count(table, sort = TRUE) was key - tables with MORE "never married" variables likely had more detailed breakdowns.


### Iterative Refinement

Each search failure taught me something:

B07008 ‚Üí Geographic mobility (not useful)
B12001 ‚Üí Marital status by sex (useful!)
B20001 ‚Üí Earnings by income brackets (not marital status)
B20017 ‚Üí Median earnings by sex (useful!)



### The "Meta" Search
When specific searches failed, I searched for what kinds of data exist:

```{r}
#| eval: true

# What earnings tables exist at all?
earnings_tables <- all_vars_acs5 %>%
  filter(str_starts(name, "B20")) %>%
  distinct(table = str_extract(name, "^[A-Z][0-9]+"), concept)

```

### Recognizing Data Structure Limitations

The key insight came from NOT finding what we wanted:

Found sex √ó marital status ‚úì
Found sex √ó earnings ‚úì
But NO sex √ó marital status √ó earnings ‚úó


This pattern meant ‚Üí need microdata (PUMS)

### Key Strategies I Used:

* Start with concepts, not table numbers

* Use str_detect() with flexible patterns (not exact matches)

* Explore table structure when you find something close

* Count occurrences to find detailed tables

* Look for systematic patterns in variable numbering



***Conclusion:  When you can't find a three-way cross, you probably need PUMS***




## Key Realization

Standard ACS tables provide:

* Earnings by sex OR

* Population by sex and marital status

* But NOT earnings by sex AND marital status together

This meant we needed custom crosstabs ‚Üí PUMS


## PUMS Solution

```{r}
#| eval: true
#| results: hide


# Downloaded microdata with individual-level records
tx_pums <- get_pums(
  variables = c("SEX", "MAR", "WAGP", "WKHP", "ESR"),
  state = "TX", 
  year = 2023
)

```


5. Analysis Refinements

Basic comparison: All males vs never-married females

Result: Large gap (contradicting Sowell)


Controlled for hours: Exactly 40 hours/week

Result: Gap persisted


Professional proxy: Used $60k+ earnings as proxy for professional jobs

Result: Gap narrowed but remained


Very high earners: $100k+ comparison

Result: Smallest gap (89%) but still present



## Key Insights from Our Process:

### When to use standard ACS tables:

* Single demographic breakdowns

* Common pre-calculated statistics

* Geographic comparisons


### When to go straight to PUMS:

* Custom crosstabs (like earnings √ó sex √ó marital status)

* Need individual-level controls

* Complex filtering conditions

* Research replication requiring specific variable combinations


### Should you go PUMS first?

Yes, if you need:

* Multiple variables crossed in ways ACS doesn't provide

* To control for several factors simultaneously

* To replicate academic research

* Custom age ranges, hour brackets, etc.


No, stick with ACS tables if:

* You need standard statistics by standard geographies

* You want margins of error calculated for you

* You're doing simple comparisons

* You need small geography data (PUMS uses PUMAs, not school districts)



### The Proxy Innovation

When we lacked occupation codes, using wage levels ($60k+, $100k+) as a proxy for professional status was clever because:

* High wages correlate with professional occupations

* It allowed testing Sowell's hypothesis about professional women

* Showed the gap narrows but persists at higher income levels


This workflow shows how exploratory data analysis often requires pivoting from the original plan when you discover data limitations!




# Sowell's comparison - Part 1

```{r}
#| eval: true
#| results: hide


tx_pums <- get_pums(
  variables = c("SEX", "MAR", "WAGP", "WKHP", "ESR"), 
  state = "TX",
  survey = "acs5",
  year = 2023
)

```

```{r}

dplyr::glimpse(tx_pums)

```

# Sowell's comparison - Part 2 of 2


```{r}
#| eval: true


# High earners as proxy for professionals
professionals_proxy <- tx_pums %>%
  filter(
    WAGP >= 60000,  # $60k+ as professional proxy
    WKHP == 40,
    ESR %in% c("1", "2")
  ) %>%
  mutate(
    group = case_when(
      SEX == "1" ~ "Male",
      SEX == "2" & MAR == "5" ~ "Female Never Married",
      TRUE ~ "Female Other"
    )
  ) %>%
  group_by(group) %>%
  summarise(
    median_wage = median(WAGP),
    n = n()
  )

glimpse(professionals_proxy)

```

# Statistically different?

```{r}
#| eval: true


# Statistical test for professional wages
prof_test <- tx_pums %>%
  filter(WAGP >= 60000, WKHP == 40, ESR %in% c("1", "2")) %>%
  filter(SEX == "1" | (SEX == "2" & MAR == "5"))  # Males vs never-married females

t.test(WAGP ~ SEX, data = prof_test)

```


# Compare very high earners

```{r}
#| eval: true



# Since we don't have education in our data, let's look at very high earners
# where education is likely similar
very_high_earners <- tx_pums %>%
  filter(
    WAGP >= 100000,  # $100k+ 
    WKHP == 40,
    ESR %in% c("1", "2")
  ) %>%
  mutate(
    group = case_when(
      SEX == "1" ~ "Male",
      SEX == "2" & MAR == "5" ~ "Female Never Married"
    )
  ) %>%
  filter(group %in% c("Male", "Female Never Married")) %>%
  group_by(group) %>%
  summarise(
    median_wage = median(WAGP),
    mean_wage = mean(WAGP),
    n = n()
  )

glimpse(very_high_earners)

```




